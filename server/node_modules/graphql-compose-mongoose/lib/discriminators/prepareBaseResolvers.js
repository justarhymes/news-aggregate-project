"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.prepareBaseResolvers = prepareBaseResolvers;

var _resolvers = require("../resolvers");

var _DiscriminatorTypeComposer = require("./DiscriminatorTypeComposer");

// change type on DKey generated by composeWithMongoose
// set it to created enum ObjectTypeComposer for DKey DKeyETC
// only sets on filter and record typeComposers, since they contain our DKey
function setDKeyEnumOnITCArgs(resolver, baseTC) {
  // setDKeyEnum for filter types, and on record types
  if (resolver) {
    const argNames = resolver.getArgNames();

    for (const argName of argNames) {
      if (argName === 'filter' || argName === 'record' || argName === 'records') {
        const filterArgTC = resolver.getArgITC(argName);

        if (filterArgTC) {
          filterArgTC.extendField(baseTC.getDKey(), {
            type: baseTC.getDKeyETC()
          });
        }
      }
    }
  }
} // recomposing sets up the DInterface as the return types for
// Also sets up DKey enum as type for DKey field on composers with filter and/or record args
// composeWithMongoose composers


function prepareBaseResolvers(baseTC) {
  for (const resolverName in _resolvers.EMCResolvers) {
    if (_resolvers.EMCResolvers.hasOwnProperty(resolverName) && baseTC.hasResolver(resolverName)) {
      const resolver = baseTC.getResolver(resolverName);

      switch (resolverName) {
        case _resolvers.EMCResolvers.findMany:
        case _resolvers.EMCResolvers.findByIds:
          resolver.setType(baseTC.getDInterface().getTypePlural());
          resolver.projection[baseTC.getDKey()] = 1;
          break;

        case _resolvers.EMCResolvers.findById:
        case _resolvers.EMCResolvers.findOne:
          resolver.setType(baseTC.getDInterface());
          resolver.projection[baseTC.getDKey()] = 1;
          break;

        case _resolvers.EMCResolvers.createOne:
        case _resolvers.EMCResolvers.updateOne:
        case _resolvers.EMCResolvers.updateById:
        case _resolvers.EMCResolvers.removeOne:
        case _resolvers.EMCResolvers.removeById:
          resolver.getOTC().extendField('record', {
            type: baseTC.getDInterface(),
            projection: {
              [baseTC.getDKey()]: 1
            }
          });
          break;

        case _resolvers.EMCResolvers.createMany:
          resolver.getOTC().extendField('records', {
            type: baseTC.getDInterface().getTypePlural().getTypeNonNull(),
            projection: {
              [baseTC.getDKey()]: 1
            }
          });
          break;

        case _resolvers.EMCResolvers.pagination:
          resolver.getOTC().extendField('items', {
            type: baseTC.getDInterface().getTypePlural(),
            projection: {
              [baseTC.getDKey()]: 1
            }
          });
          break;

        case _resolvers.EMCResolvers.connection:
          const edgesTC = resolver // eslint-disable-line no-case-declarations
          .getOTC().getFieldOTC('edges').clone(`${baseTC.getTypeName()}Edge`);
          edgesTC.extendField('node', {
            type: baseTC.getDInterface().getTypeNonNull(),
            projection: {
              [baseTC.getDKey()]: 1
            }
          });
          resolver.getOTC().setField('edges', edgesTC.getTypeNonNull().getTypePlural().getTypeNonNull());
          break;

        default:
      }

      setDKeyEnumOnITCArgs(resolver, baseTC); // set DKey as required field to create from base
      // must be done after setting DKeyEnum

      if (resolverName === _resolvers.EMCResolvers.createOne || resolverName === _resolvers.EMCResolvers.createMany) {
        const fieldName = resolverName === _resolvers.EMCResolvers.createMany ? 'records' : 'record';
        resolver.getArgITC(fieldName).extendField(baseTC.getDKey(), {
          type: baseTC.getDKeyETC().getTypeNonNull()
        });
      }
    }
  }
}