"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var child_process_1 = require("child_process");
// ApolloEngineLauncher knows how to run an engineproxy binary, wait for it to
// be listening, learn on what address it is listening, and restart it when it
// crashes. It doesn't know how to automatically connect it to a GraphQL server
// in this process --- that's what ApolloEngine is for. It's used to implement
// ApolloEngine, and it's an alternative to the Docker container for folks who
// want to put engineproxy in front of a non-Node GraphQL server.
var ApolloEngineLauncher = /** @class */ (function (_super) {
    __extends(ApolloEngineLauncher, _super);
    // The constructor takes the same argument as ApolloEngine: the underlying
    // engineproxy config file.  Note that unlike the ApolloEngine constructor,
    // the config is mandatory, because you need to at least define an origin URL.
    function ApolloEngineLauncher(config) {
        var _this = _super.call(this) || this;
        _this.config = config;
        _this.child = null;
        switch (process.platform) {
            case 'darwin':
                _this.binary = require.resolve('apollo-engine-binary-darwin/engineproxy_darwin_amd64');
                break;
            case 'linux':
                _this.binary = require.resolve('apollo-engine-binary-linux/engineproxy_linux_amd64');
                break;
            case 'win32':
                _this.binary = require.resolve('apollo-engine-binary-windows/engineproxy_windows_amd64.exe');
                break;
            default:
                throw new Error('Unsupported platform');
        }
        return _this;
    }
    // start takes the same options as the launcherOptions option to
    // `ApolloEngine.listen`. It runs engineproxy, returning a Promise that
    // resolves once engineproxy is listening, or rejects if startup fails
    // (including due to a timeout). It restarts engineproxy if it exits for any
    // reason other than invalid config (emitting 'restarting' as it does so).
    // The Promise resolves to a structure telling on what port engineproxy is
    // listening.
    ApolloEngineLauncher.prototype.start = function (options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        if (this.child) {
            throw new Error('Only call start() on an ApolloEngineLauncher object once');
        }
        var spawnChild = function () {
            // We want to read from engineproxy's special listening reporter fd 3
            // (which we tell it about with an env var). We let it write directly to
            // our stdout and stderr (unless the user passes in their own output
            // streams) so we don't spend CPU copying output around (and if we crash
            // for some reason, engineproxy's output still gets seen). We don't care
            // about engineproxy's stdin.
            //
            // We considered having stdout and stderr always wrapped with a prefix. We
            // used to do this before we switched to JSON but apparently it was slow:
            // https://github.com/apollographql/apollo-engine-js/pull/50#discussion_r153961664
            // Users can use proxyStd*Stream to do this themselves, and we can make it
            // easier if it's popular.
            var stdio = ['ignore', 'inherit', 'inherit', 'pipe'];
            // If we are provided writable streams, ask child_process to create a pipe
            // which we will pipe to them. (We could put the streams directly in
            // `stdio` but this only works for pipes based directly on files.)
            if (options.proxyStdoutStream) {
                stdio[1] = 'pipe';
            }
            if (options.proxyStderrStream) {
                stdio[2] = 'pipe';
            }
            var args = ['-listening-reporter-fd=3'];
            var env = Object.assign({}, process.env);
            if (typeof _this.config === 'string') {
                // Load config from a file. engineproxy will watch the file for changes.
                args.push("-config=" + _this.config);
            }
            else {
                args.push("-config=env");
                env.ENGINE_CONFIG = JSON.stringify(_this.config);
            }
            // Add extra arguments; used by ApolloEngine and by tests.
            if (options.extraArgs) {
                options.extraArgs.forEach(function (a) { return args.push(a); });
            }
            // Add extra environment variables. Used by tests.
            if (options.extraEnv) {
                Object.keys(options.extraEnv).forEach(function (k) {
                    env[k] = options.extraEnv[k];
                });
            }
            var child = child_process_1.spawn(_this.binary, args, { stdio: stdio, env: env });
            _this.child = child;
            // Hook up custom logging streams, if provided. We don't end the streams
            // when the child ends, as we may run several restarting childs against
            // one set of output streams.
            if (options.proxyStdoutStream) {
                child.stdout.pipe(options.proxyStdoutStream, { end: false });
            }
            if (options.proxyStderrStream) {
                child.stderr.pipe(options.proxyStderrStream, { end: false });
            }
            var listeningAddress = '';
            child.stdio[3].on('data', function (chunk) {
                listeningAddress += chunk.toString();
            });
            child.stdio[3].on('end', function () {
                // If we read something, then it started. (If not, then this is probably
                // just end of process cleanup.)
                if (listeningAddress !== '') {
                    // Notify that proxy has started. The object is of the form `{ip:
                    // "127.0.0.1", port: 1234}`.
                    var la = JSON.parse(listeningAddress);
                    // Convert IPs which mean "any address" (IPv4 or IPv6) into localhost
                    // corresponding loopback ip. Note that the url field we're setting is
                    // primarily for consumption by our test suite. If this heuristic is
                    // wrong for your use case, explicitly specify a frontend host (in the
                    // `frontends.host` field in your engine config, or in the `host`
                    // option to ApolloEngine.listen).
                    if (ApolloEngineLauncher.isTcp(la)) {
                        // we are listening via TCP
                        var hostForUrl = la.ip;
                        if (la.ip === '' || la.ip === '::') {
                            hostForUrl = 'localhost';
                        }
                        la.url = "http://" + joinHostPort(hostForUrl, la.port);
                    }
                    _this.emit('start', la);
                }
            });
            // Re-emit any errors from talking to engineproxy.
            // XXX Not super clear if this will happen in practice, but at least
            //     if it does, doing it this way will make it clear that the error
            //     is coming from Engine.
            child.stdio[3].on('error', function (err) { return _this.emit('error', err); });
            // Connect shutdown hooks:
            child.on('exit', function (code, signal) {
                if (!_this.child) {
                    // It's not an error if we've killed it (due to timeout or stop()).
                    return;
                }
                if (code === 78) {
                    _this.emit('error', new Error('Engine crashed due to invalid configuration.'));
                    return;
                }
                if (code != null) {
                    _this.emitRestarting("Engine crashed unexpectedly with code: " + code);
                }
                if (signal != null) {
                    _this.emitRestarting("Engine was killed unexpectedly by signal: " + signal);
                }
                spawnChild();
            });
        };
        spawnChild();
        this.setUpStopEvents(options.processCleanupEvents || [
            'exit',
            'uncaughtException',
            'SIGINT',
            'SIGTERM',
            // We mostly care about SIGUSR2 because nodemon uses it.
            'SIGUSR2',
        ]);
        return new Promise(function (resolve, reject) {
            var startupErrorHandler;
            var cancelTimeout;
            if (options.startupTimeout === undefined || options.startupTimeout > 0) {
                cancelTimeout = setTimeout(function () {
                    if (_this.child) {
                        _this.child.kill('SIGKILL');
                        _this.child = null;
                    }
                    _this.removeListener('error', startupErrorHandler);
                    reject(Error('engineproxy timed out'));
                }, options.startupTimeout || 5000);
            }
            _this.on('start', function (listeningAddress) {
                clearTimeout(cancelTimeout);
                _this.removeListener('error', startupErrorHandler);
                resolve(listeningAddress);
            });
            // Errors during startup turn into rejections of the 'start'
            // Promise. Later errors are just emitted as 'error' events (as are
            // startup errors).
            startupErrorHandler = function (error) {
                clearTimeout(cancelTimeout);
                _this.child = null;
                reject(error);
            };
            _this.once('error', startupErrorHandler);
        });
    };
    // Stops the process. The returned Promise resolves once the child has exited.
    ApolloEngineLauncher.prototype.stop = function () {
        if (this.child === null) {
            throw new Error('No engine instance running!');
        }
        if (this.eventStopper) {
            this.eventStopper();
        }
        var childRef = this.child;
        this.child = null;
        return new Promise(function (resolve) {
            childRef.on('exit', function () {
                resolve();
            });
            childRef.kill();
        });
    };
    ApolloEngineLauncher.isTcp = function (listeningAddress) {
        return listeningAddress.port !== undefined;
    };
    ApolloEngineLauncher.prototype.emitRestarting = function (error) {
        if (!this.emit('restarting', new Error(error))) {
            // No listeners; default to console.error.
            console.error(error);
        }
    };
    ApolloEngineLauncher.prototype.setUpStopEvent = function (event) {
        var _this = this;
        var handler = function (maybeError) {
            var childPromise = Promise.resolve();
            // Kill the child if it's running.
            if (_this.child) {
                // Note that in the case of the 'exit' event we're not going to
                // actually get a chance to wait for anything to happen, but at least
                // we'll fire off the signal.
                childPromise = _this.stop();
            }
            // For uncaughtException, rethrow the error. This does slightly change the
            // printed error (but not its stack trace) and converts the exit status of
            // 1 into 7, but it's pretty close. We do this synchronously rather than
            // allow the program to keep running after uncaught exception. Note that
            // we don't allow this function to be an async function, so that this
            // throw is truly synchronous.
            if (event === 'uncaughtException') {
                throw maybeError;
            }
            if (event.startsWith('SIG')) {
                // Wait for the child to finish. In a signal handler we can afford to
                // be asynchronous, unlike with 'exit' or 'uncaughtException'.
                childPromise.then(function () {
                    // Re-signal self. Since this was a 'once', the signal won't hit this
                    // handler again. Re-signaling ourself means that our exit status will
                    // be as if we were killed by the signal we received, which is
                    // something that things like nodemon like to see.
                    process.kill(process.pid, event);
                });
            }
        };
        process.once(event, handler);
        return handler;
    };
    ApolloEngineLauncher.prototype.setUpStopEvents = function (events) {
        var _this = this;
        var handlers = new Map();
        events.forEach(function (event) {
            // Process any given event at most once.
            if (handlers.has(event)) {
                return;
            }
            handlers.set(event, _this.setUpStopEvent(event));
        });
        this.eventStopper = function () {
            handlers.forEach(function (handler, event) {
                process.removeListener(event, handler);
            });
            delete _this.eventStopper;
        };
    };
    return ApolloEngineLauncher;
}(events_1.EventEmitter));
exports.ApolloEngineLauncher = ApolloEngineLauncher;
// Literal IPv6 addresses contain colons and need to be wrapped in square
// brackets (like Go's net.JoinHostPort).
function joinHostPort(host, port) {
    if (host.includes(':')) {
        host = "[" + host + "]";
    }
    return host + ":" + port;
}
exports.joinHostPort = joinHostPort;
//# sourceMappingURL=launcher.js.map