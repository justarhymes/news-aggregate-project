"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var request = require("request");
var path_1 = require("path");
var child_process_1 = require("child_process");
var sinon_1 = require("sinon");
var schema_1 = require("./schema");
var engine_1 = require("../engine");
var acceptableEndings = ['/', '?', '?123', '/?123'];
function runSuite(before, hasTracing, frameworkName) {
    var _this = this;
    var url;
    // micro has an unconfigurable behavior to console.error any error thrown by a
    // handler (https://github.com/zeit/micro/issues/329).  We use sinon to
    // override console.error; however, we use callThrough to ensure that by
    // default, it just calls console.error normally. The tests that throw errors
    // tell the stub to "stub out" console.error on the first call.
    var consoleErrorStub;
    beforeEach(function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    consoleErrorStub = sinon_1.stub(console, 'error');
                    consoleErrorStub.callThrough();
                    return [4 /*yield*/, before()];
                case 1:
                    url = _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    afterEach(function () {
        consoleErrorStub.restore();
    });
    test('processes successful query', function () {
        return schema_1.verifyEndpointSuccess(url, hasTracing);
    });
    acceptableEndings.forEach(function (acceptableEnding) {
        test("using server endpoint " + acceptableEnding, function () {
            return schema_1.verifyEndpointSuccess(url + acceptableEnding, hasTracing);
        });
    });
    test('processes successful GET query', function () {
        return schema_1.verifyEndpointGet(url, hasTracing);
    });
    test('processes invalid query', function () {
        if (frameworkName === 'micro') {
            consoleErrorStub.onFirstCall().returns(undefined);
        }
        return schema_1.verifyEndpointFailure(url);
    });
    test('processes query that errors', function () {
        return schema_1.verifyEndpointError(url);
    });
    test('processes batched queries', function () {
        return schema_1.verifyEndpointBatch(url, hasTracing);
    });
    test('returns cache information', function () { return __awaiter(_this, void 0, void 0, function () {
        var body;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, schema_1.verifyEndpointSuccess(url, hasTracing)];
                case 1:
                    body = _a.sent();
                    expect(body['extensions'] && body['extensions']['cacheControl']).toBeDefined();
                    return [2 /*return*/];
            }
        });
    }); });
    test('http proxying works', function (done) {
        var childUrl = url + "/ping";
        request(childUrl, function (err, response, body) {
            expect(err).toBe(null);
            expect(body).toBe('{"pong":true}');
            done();
        });
    });
}
exports.runSuite = runSuite;
function runSuitesForHttpServerFramework(frameworkName, _a) {
    var _this = this;
    var createApp = _a.createApp, serverForApp = _a.serverForApp, appParameter = _a.appParameter;
    describe(frameworkName + " integration", function () {
        var httpServers = [];
        var engine;
        beforeEach(function () {
            engine = null;
            httpServers = [];
        });
        afterEach(function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!engine) return [3 /*break*/, 2];
                        return [4 /*yield*/, engine.stop()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        httpServers.forEach(function (server) { return server.close(); });
                        return [2 /*return*/];
                }
            });
        }); });
        function gqlServer() {
            var app = createApp();
            var server = serverForApp(app);
            httpServers.push(server);
            return server.listen().address().port;
        }
        describe('without engine', function () {
            runSuite(function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, "http://localhost:" + gqlServer() + "/graphql"];
                });
            }); }, true, frameworkName);
        });
        describe('with engine', function () {
            runSuite(function () { return __awaiter(_this, void 0, void 0, function () {
                var app, p;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            app = createApp();
                            engine = new engine_1.ApolloEngine({
                                apiKey: 'faked',
                                logging: {
                                    level: 'WARN',
                                    destination: 'STDERR',
                                },
                                reporting: {
                                    disabled: true,
                                },
                                frontends: [
                                    {
                                        extensions: {
                                            strip: ['tracing'],
                                        },
                                    },
                                ],
                            });
                            p = new Promise(function (resolve) {
                                engine.listen((_a = {
                                        // Let engineproxy get an ephemeral port; we'll learn about it in the
                                        // listening callback.
                                        port: 0
                                    },
                                    _a[appParameter] = app,
                                    _a.launcherOptions = {
                                        extraEnv: {
                                            // engineproxy should only try to connect to our origin
                                            // (reporting is diabled), which is on localhost, so this
                                            // bad proxy should be ignored. This is a regression test
                                            // from back when we would put unspecified IPs in the origin
                                            // URL by default (instead of listening on 127.0.0.1 by
                                            // default) and the Go http library would try to use the
                                            // proxy (https://github.com/golang/go/issues/24737).
                                            HTTP_PROXY: 'http://bad.proxy.example.com/',
                                        },
                                    },
                                    _a), function () {
                                    resolve(engine.engineListeningAddress.url + "/graphql");
                                });
                                var _a;
                            });
                            return [4 /*yield*/, p];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            }); }, false, frameworkName);
        });
    });
}
exports.runSuitesForHttpServerFramework = runSuitesForHttpServerFramework;
function runCleanupTests(forLauncher) {
    var _this = this;
    describe('engineproxy cleaned up', function () {
        ['SIGINT', 'SIGTERM', 'SIGUSR2', 'uncaughtException', 'exit'].forEach(function (event) {
            test("on " + event, function () { return __awaiter(_this, void 0, void 0, function () {
                var env, child, proxyPid, childDone;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // There is no SIGUSR2 on Windows.
                            if (event === 'SIGUSR2' && process.platform === 'win32') {
                                return [2 /*return*/];
                            }
                            env = __assign({}, process.env);
                            if (forLauncher) {
                                env.AEJ_TEST_LAUNCHER = 't';
                            }
                            if (event === 'uncaughtException') {
                                env.AEJ_TEST_UNCAUGHT_EXCEPTION = 't';
                            }
                            if (event === 'exit') {
                                env.AEJ_TEST_PROCESS_EXIT = 't';
                            }
                            child = child_process_1.fork(path_1.join(__dirname, 'child.js'), [], {
                                env: env,
                                // You may want to remove the following line to debug failures in
                                // these tests.
                                silent: true,
                            });
                            return [4 /*yield*/, new Promise(function (resolve) {
                                    child.on('message', function (m) {
                                        resolve(m.pid);
                                    });
                                })];
                        case 1:
                            proxyPid = _a.sent();
                            // Verify that the proxy exists.
                            process.kill(proxyPid, 0);
                            childDone = new Promise(function (resolve) {
                                child.on('exit', resolve);
                            });
                            if (event.startsWith('SIG')) {
                                child.kill(event);
                            }
                            return [4 /*yield*/, childDone];
                        case 2:
                            _a.sent();
                            if (!(event === 'exit' || event === 'uncaughtException')) return [3 /*break*/, 4];
                            return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, 10); })];
                        case 3:
                            _a.sent();
                            _a.label = 4;
                        case 4:
                            // Verify that the proxy is gone.
                            expect(function () { return process.kill(proxyPid, 0); }).toThrow();
                            return [2 /*return*/];
                    }
                });
            }); });
        });
    });
}
exports.runCleanupTests = runCleanupTests;
//# sourceMappingURL=engine-common.js.map