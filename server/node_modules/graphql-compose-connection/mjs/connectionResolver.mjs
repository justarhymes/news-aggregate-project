function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable no-param-reassign, no-use-before-define */
import { ObjectTypeComposer, inspect } from 'graphql-compose';
import { prepareConnectionType } from './types/connectionType';
import { prepareSortType } from './types/sortInputType';
import { cursorToData, dataToCursor } from './cursor';
export function prepareConnectionResolver(tc, opts) {
  if (!(tc instanceof ObjectTypeComposer)) {
    throw new Error(`First arg for prepareConnectionResolver() should be instance of ObjectTypeComposer but recieved: ${inspect(tc)}`);
  }

  if (!opts.countResolverName) {
    throw new Error(`ObjectTypeComposer(${tc.getTypeName()}) provided to composeWithConnection ` + 'should have option `opts.countResolverName`.');
  }

  const countResolver = tc.getResolver(opts.countResolverName);

  if (!countResolver) {
    throw new Error(`ObjectTypeComposer(${tc.getTypeName()}) provided to composeWithConnection ` + `should have resolver with name '${opts.countResolverName}' ` + 'due opts.countResolverName.');
  }

  const countResolve = countResolver.getResolve();

  if (!opts.findResolverName) {
    throw new Error(`ObjectTypeComposer(${tc.getTypeName()}) provided to composeWithConnection ` + 'should have option `opts.findResolverName`.');
  }

  const findManyResolver = tc.getResolver(opts.findResolverName);

  if (!findManyResolver) {
    throw new Error(`ObjectTypeComposer(${tc.getTypeName()}) provided to composeWithConnection ` + `should have resolver with name '${opts.findResolverName}' ` + 'due opts.countResolverName.');
  }

  const findManyResolve = findManyResolver.getResolve();
  const additionalArgs = {};

  if (findManyResolver.hasArg('filter')) {
    const filter = findManyResolver.getArg('filter');

    if (filter) {
      additionalArgs.filter = filter;
    }
  }

  const sortEnumType = prepareSortType(tc, opts);
  const firstField = sortEnumType.getFieldNames()[0];
  const defaultValue = firstField && sortEnumType.getField(firstField).value;
  return tc.schemaComposer.createResolver({
    type: prepareConnectionType(tc, opts.connectionResolverName, opts.edgeTypeName, opts.edgeFields),
    name: opts.connectionResolverName || 'connection',
    kind: 'query',
    args: _objectSpread({
      first: {
        type: 'Int',
        description: 'Forward pagination argument for returning at most first edges'
      },
      after: {
        type: 'String',
        description: 'Forward pagination argument for returning at most first edges'
      },
      last: {
        type: 'Int',
        description: 'Backward pagination argument for returning at most last edges'
      },
      before: {
        type: 'String',
        description: 'Backward pagination argument for returning at most last edges'
      }
    }, additionalArgs, {
      sort: {
        type: sortEnumType,
        defaultValue,
        description: 'Sort argument for data ordering'
      }
    }),

    async resolve(resolveParams) {
      let countPromise;
      let findManyPromise;
      const {
        projection = {},
        args,
        rawQuery
      } = resolveParams;

      const findManyParams = _objectSpread({}, resolveParams);

      let first = parseInt(args.first, 10) || 0;

      if (first < 0) {
        throw new Error('Argument `first` should be non-negative number.');
      }

      const last = parseInt(args.last, 10) || 0;

      if (last < 0) {
        throw new Error('Argument `last` should be non-negative number.');
      }

      const countParams = _objectSpread({}, resolveParams, {
        rawQuery,
        args: {
          filter: _objectSpread({}, resolveParams.args.filter)
        }
      });

      if (projection.count) {
        countPromise = countResolve(countParams);
      } else if (!first && last) {
        countPromise = countResolve(countParams);
      } else {
        countPromise = Promise.resolve(0);
      }

      if (projection && projection.edges) {
        // combine top level projection
        // (maybe somebody add additional fields via resolveParams.projection)
        // and edges.node (record needed fields)
        const extraProjection = opts.edgeFields ? projection.edges : projection.edges.node;
        findManyParams.projection = _objectSpread({}, projection, {}, extraProjection);
      } else {
        findManyParams.projection = _objectSpread({}, projection);
      } // Apply the rawQuery to the count to get accurate results with last and
      // before


      const sortConfig = findSortConfig(opts.sort, args.sort);

      if (sortConfig) {
        prepareRawQuery(resolveParams, sortConfig);
      }

      if (!first && last) {
        // Get the number of edges targeted by the findMany resolver (not the
        // whole count)
        const filteredCountParams = _objectSpread({}, resolveParams, {
          args: {
            filter: _objectSpread({}, resolveParams.args.filter)
          }
        });

        first = await countResolve(filteredCountParams);
        first = parseInt(first, 10) || 0;
      }

      let limit = last || first || opts.defaultLimit || 20;
      let skip = last > 0 ? first - last : 0;
      let prepareCursorData;

      if (sortConfig) {
        findManyParams.rawQuery = resolveParams.rawQuery;
        sortConfig.cursorFields.forEach(fieldName => {
          findManyParams.projection[fieldName] = true;
        });

        prepareCursorData = record => {
          const result = {};
          sortConfig.cursorFields.forEach(fieldName => {
            result[fieldName] = record[fieldName];
          });
          return result;
        };
      } else {
        [limit, skip] = prepareLimitSkipFallback(resolveParams, limit, skip);
        let skipIdx = -1; // eslint-disable-next-line

        prepareCursorData = _ => {
          skipIdx += 1;
          return skip + skipIdx;
        };
      }

      findManyParams.args.limit = limit + 1; // +1 document, to check next page presence

      if (skip > 0) {
        findManyParams.args.skip = skip;
      } // pass findMany ResolveParams to top resolver


      resolveParams.findManyResolveParams = findManyParams;
      resolveParams.countResolveParams = countParams; // This allows to optimize and not actually call the findMany resolver
      // if only the count is projected

      if (projection.count && Object.keys(projection).length === 1) {
        findManyPromise = Promise.resolve([]);
      } else {
        findManyPromise = findManyResolve(findManyParams);
      }

      return Promise.all([findManyPromise, countPromise]).then(([recordList, count]) => {
        // transform record to object { cursor, node, ...edge}
        const edges = recordList.map(record => {
          const edge = {
            cursor: dataToCursor(prepareCursorData(record)),
            node: opts.edgeFields ? record.node : record
          };

          if (opts.edgeFields) {
            // Sometimes the value from `findMany` can't be spread
            Object.keys(opts.edgeFields).forEach(field => {
              edge[field] = record[field];
            });
          }

          return edge;
        });
        return [edges, count];
      }).then(([edges, count]) => {
        const result = emptyConnection();
        result.edges = edges.length > limit ? edges.slice(0, limit) : edges;
        result.pageInfo = preparePageInfo(edges, args, limit, skip);
        result.count = count;
        return result;
      });
    }

  });
}
export function preparePageInfo(edges, args, limit, skip) {
  const pageInfo = {
    startCursor: '',
    endCursor: '',
    hasPreviousPage: false,
    hasNextPage: false
  };
  const hasExtraRecords = edges.length > limit; // pageInfo may be extended, so set data gradually

  if (edges.length > 0 && limit > 0) {
    pageInfo.startCursor = edges[0].cursor;

    if (hasExtraRecords) {
      pageInfo.endCursor = edges[limit - 1].cursor;
    } else {
      pageInfo.endCursor = edges[edges.length - 1].cursor;
    }

    pageInfo.hasPreviousPage = skip > 0 || !!args.after;
    pageInfo.hasNextPage = hasExtraRecords || !!args.before;
  }

  return pageInfo;
}
export function prepareRawQuery(rp, sortConfig) {
  if (!rp.rawQuery) {
    rp.rawQuery = {};
  }

  const beginCursorData = cursorToData(rp.args.after);

  if (beginCursorData) {
    const r = sortConfig.afterCursorQuery(rp.rawQuery, beginCursorData, rp);

    if (r !== undefined) {
      rp.rawQuery = r;
    }
  }

  const endCursorData = cursorToData(rp.args.before);

  if (endCursorData) {
    const r = sortConfig.beforeCursorQuery(rp.rawQuery, endCursorData, rp);

    if (r !== undefined) {
      rp.rawQuery = r;
    }
  }
}
export function prepareLimitSkipFallback(rp, limit, skip) {
  let newLimit = limit;
  let newSkip = skip;
  let beforeSkip = 0;
  let afterSkip = 0;

  if (rp.args.before) {
    const tmp = cursorToData(rp.args.before);

    if (Number.isInteger(tmp)) {
      beforeSkip = parseInt(tmp, 10);
    }
  }

  if (rp.args.after) {
    const tmp = cursorToData(rp.args.after);

    if (Number.isInteger(tmp)) {
      afterSkip = parseInt(tmp, 10) + 1;
    }
  }

  if (beforeSkip && afterSkip) {
    const rangeLimit = beforeSkip - afterSkip;

    if (rangeLimit < 0) {
      newLimit = 0;
      newSkip = skip + afterSkip;
    } else if (rangeLimit < limit) {
      newLimit = rangeLimit;
      newSkip = skip + beforeSkip - rangeLimit;
    } else {
      newSkip = skip + afterSkip;
    }
  } else if (beforeSkip) {
    // just simple backward listing (without after arg)
    // so we simple take previous records reducing skip by limit value
    newSkip = beforeSkip - limit;

    if (newSkip < 0) {
      newSkip = 0;
      newLimit = limit; // offset 0, so limit should not exceed offset in cursor,
      // otherwise it returns again this record

      if (newLimit > beforeSkip) {
        newLimit = beforeSkip;
      }
    }
  } else if (afterSkip) {
    newSkip = afterSkip;
  }

  return [newLimit, newSkip];
}
export function emptyConnection() {
  return {
    count: 0,
    edges: [],
    pageInfo: {
      startCursor: '',
      endCursor: '',
      hasPreviousPage: false,
      hasNextPage: false
    }
  };
}
export function findSortConfig(configs, val) {
  // Object.keys(configs).forEach(k => {  // return does not works in forEach as
  // I want
  for (const k in configs) {
    if (configs[k].value === val) {
      return configs[k];
    }
  } // Yep, I know that it's now good comparision, but fast solution for now
  // Sorry but complex sort value should has same key ordering
  //   cause {a: 1, b: 2} != {b: 2, a: 1}
  // BTW this code will be called only if arg.sort setuped by hands
  //   if graphql provides arg.sort, then first for-loop (above) done all work


  const valStringified = JSON.stringify(val);

  for (const k in configs) {
    if (JSON.stringify(configs[k].value) === valStringified) {
      return configs[k];
    }
  }

  return undefined;
}