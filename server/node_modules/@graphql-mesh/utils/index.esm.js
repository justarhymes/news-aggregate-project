import { fetchache, Request, Headers } from 'fetchache';
import isUrl from 'is-url';
export { default as isUrl } from 'is-url';
import { safeLoad } from 'js-yaml';
import { isAbsolute, resolve, join } from 'path';
import { stat, readFile } from 'fs-extra';
import { Interpolator } from '@ardatan/string-interpolation';
import { format } from 'date-fns';
import objectHash from 'object-hash';
import { GraphQLNonNull, GraphQLID } from 'graphql';
import { getResolversFromSchema } from '@graphql-tools/utils';

async function readFileOrUrlWithCache(filePathOrUrl, cache, config) {
    if (isUrl(filePathOrUrl)) {
        return readUrlWithCache(filePathOrUrl, cache, config);
    }
    else {
        return readFileWithCache(filePathOrUrl, cache, config);
    }
}
async function readFileWithCache(filePath, cache, config) {
    const actualPath = isAbsolute ? filePath : resolve(process.cwd(), filePath);
    const cachedObjStr = await cache.get(actualPath);
    const stats = await stat(actualPath);
    if (cachedObjStr) {
        const cachedObj = JSON.parse(cachedObjStr);
        if (stats.mtimeMs <= cachedObj.mtimeMs) {
            return cachedObj.result;
        }
    }
    let result = await readFile(actualPath, 'utf-8');
    if (/json$/.test(filePath)) {
        result = JSON.parse(result);
    }
    else if (/yaml$/.test(filePath) || /yml$/.test(filePath)) {
        result = safeLoad(result);
    }
    else if (!(config === null || config === void 0 ? void 0 : config.allowUnknownExtensions)) {
        throw new Error(`Failed to parse JSON/YAML. Ensure file '${filePath}' has ` +
            `the correct extension (i.e. '.json', '.yaml', or '.yml).`);
    }
    cache.set(filePath, JSON.stringify({ result, mtimeMs: stats.mtimeMs }));
    return result;
}
async function readUrlWithCache(path, cache, config) {
    const response = await fetchache(new Request(path, config), cache);
    const contentType = response.headers.get('content-type') || '';
    const responseText = await response.text();
    if (/json$/.test(path) || contentType.startsWith('application/json')) {
        return JSON.parse(responseText);
    }
    else if (/yaml$/.test(path) || /yml$/.test(path) || contentType.includes('yaml') || contentType.includes('yml')) {
        return safeLoad(responseText);
    }
    else if (!(config === null || config === void 0 ? void 0 : config.allowUnknownExtensions)) {
        throw new Error(`Failed to parse JSON/YAML. Ensure URL '${path}' has ` +
            `the correct extension (i.e. '.json', '.yaml', or '.yml) or mime type in the response headers.`);
    }
    return responseText;
}

const stringInterpolator = new Interpolator({
    delimiter: ['{', '}'],
});
stringInterpolator.addAlias('typeName', 'info.parentType.name');
stringInterpolator.addAlias('type', 'info.parentType.name');
stringInterpolator.addAlias('parentType', 'info.parentType.name');
stringInterpolator.addAlias('fieldName', 'info.fieldName');
stringInterpolator.registerModifier('date', (formatStr) => format(new Date(), formatStr));
stringInterpolator.registerModifier('hash', (value) => objectHash(value, { ignoreUnknown: true }));

async function loadFromModuleExportExpression(expression, defaultExportName) {
    const [modulePath, exportName = defaultExportName] = expression.split('#');
    const mod = await tryImport(modulePath);
    if (exportName === 'default' || !exportName) {
        return mod.default || mod;
    }
    else {
        return mod[exportName] || (mod.default && mod.default[exportName]);
    }
}
async function tryImport(modulePath) {
    try {
        return await import(modulePath);
    }
    catch (e1) {
        if (!isAbsolute(modulePath)) {
            try {
                const absoluteModulePath = isAbsolute(modulePath) ? modulePath : join(process.cwd(), modulePath);
                return await import(absoluteModulePath);
            }
            catch (e2) {
                if (e2.message.includes('Cannot find module')) {
                    throw e1;
                }
                else {
                    throw e2;
                }
            }
        }
        throw e1;
    }
}
function loadFromModuleExportExpressionSync(expression, defaultExportName) {
    const [modulePath, exportName = defaultExportName] = expression.split('#');
    const mod = tryImportSync(modulePath);
    if (exportName === 'default' || !exportName) {
        return mod.default || mod;
    }
    else {
        return mod[exportName] || (mod.default && mod.default[exportName]);
    }
}
function tryImportSync(modulePath) {
    try {
        return require(modulePath);
    }
    catch (e1) {
        if (!isAbsolute(modulePath)) {
            try {
                const absoluteModulePath = isAbsolute(modulePath) ? modulePath : join(process.cwd(), modulePath);
                return require(absoluteModulePath);
            }
            catch (e2) {
                if (e2.message.includes('Cannot find module')) {
                    throw e1;
                }
                else {
                    throw e2;
                }
            }
        }
        throw e1;
    }
}

function parseInterpolationStrings(interpolationStrings) {
    const interpolationKeys = interpolationStrings.reduce((keys, str) => [...keys, ...stringInterpolator.parseRules(str).map((match) => match.key)], []);
    const args = {};
    const contextVariables = [];
    for (const interpolationKey of interpolationKeys) {
        const interpolationKeyParts = interpolationKey.split('.');
        const varName = interpolationKeyParts[interpolationKeyParts.length - 1];
        if (interpolationKeyParts[0] === 'args') {
            args[varName] = {
                type: new GraphQLNonNull(GraphQLID),
            };
        }
        else if (interpolationKeyParts[0] === 'context') {
            contextVariables.push(varName);
        }
    }
    return {
        args,
        contextVariables,
    };
}
function getInterpolatedStringFactory(nonInterpolatedString) {
    return resolverData => stringInterpolator.parse(nonInterpolatedString, resolverData);
}
function getInterpolatedHeadersFactory(nonInterpolatedHeaders = {}) {
    return resolverData => {
        const headers = new Headers();
        for (const headerName in nonInterpolatedHeaders) {
            headers.set(headerName, stringInterpolator.parse(nonInterpolatedHeaders[headerName], resolverData));
        }
        return headers;
    };
}
function getHeadersObject(headers) {
    const headersObj = {};
    headers.forEach((value, key) => {
        headersObj[key] = value;
    });
    return headersObj;
}

function withCancel(asyncIteratorLike, onCancel) {
    const asyncIterator = asyncIteratorLike[Symbol.asyncIterator]();
    if (!asyncIterator.return) {
        asyncIterator.return = () => Promise.resolve({ value: undefined, done: true });
    }
    const savedReturn = asyncIterator.return.bind(asyncIterator);
    asyncIterator.return = () => {
        onCancel();
        return savedReturn();
    };
    return asyncIterator;
}

function extractResolvers(schema) {
    const allResolvers = getResolversFromSchema(schema);
    const filteredResolvers = {};
    for (const prop in allResolvers) {
        if (!prop.startsWith('_')) {
            filteredResolvers[prop] = allResolvers[prop];
        }
    }
    return filteredResolvers;
}

export { extractResolvers, getHeadersObject, getInterpolatedHeadersFactory, getInterpolatedStringFactory, loadFromModuleExportExpression, loadFromModuleExportExpressionSync, parseInterpolationStrings, readFileOrUrlWithCache, readFileWithCache, readUrlWithCache, stringInterpolator, withCancel };
//# sourceMappingURL=index.esm.js.map
