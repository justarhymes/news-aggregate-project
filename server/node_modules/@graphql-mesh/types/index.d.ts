import { IResolvers, Transform } from '@graphql-tools/utils';
import { IEventEmitter } from 'tsee';
import { GraphQLSchema, GraphQLResolveInfo, DocumentNode } from 'graphql';
import * as YamlConfig from './config';
import { KeyValueCache, KeyValueCacheSetOptions } from 'fetchache';
import { Executor, Subscriber } from '@graphql-tools/delegate';
export { YamlConfig };
export declare function getJsonSchema(): any;
export declare type MeshSource<ContextType = any, InitialContext = any> = {
    schema: GraphQLSchema;
    executor?: Executor;
    subscriber?: Subscriber;
    contextVariables?: (keyof InitialContext)[];
    contextBuilder?: (initialContextValue: InitialContext) => Promise<ContextType>;
};
export declare type GetMeshSourceOptions<THandlerConfig> = {
    name: string;
    hooks: Hooks;
    config: THandlerConfig;
    cache: KeyValueCache;
};
export declare type MeshHandlerLibrary<THandlerConfig = any, TContext = any> = {
    getMeshSource: (options: GetMeshSourceOptions<THandlerConfig>) => Promise<MeshSource<TContext>>;
};
export declare type ResolverData<TParent = any, TArgs = any, TContext = any> = {
    root?: TParent;
    args?: TArgs;
    context?: TContext;
    info?: GraphQLResolveInfo;
};
export declare type AllHooks = {
    schemaReady: (schema: GraphQLSchema) => void;
    destroy: () => void;
    resolverCalled: (resolverData: ResolverData) => void;
    resolverDone: (resolverData: ResolverData, result: any) => void;
    resolverError: (resolverData: ResolverData, error: Error) => void;
};
export declare type Hooks = IEventEmitter<AllHooks>;
export declare type HooksKeys = keyof AllHooks;
export interface MeshTransformOptions<Config = any> {
    config: Config;
    cache: KeyValueCache;
    hooks: Hooks;
    apiName?: string;
}
export interface MeshTransformLibrary<Config = any> {
    new (options: MeshTransformOptions<Config>): MeshTransform;
}
export interface MeshTransform extends Transform {
    noWrap?: boolean;
}
export declare type Maybe<T> = null | undefined | T;
export { KeyValueCache, KeyValueCacheSetOptions };
export declare type MergerFn = (options: {
    rawSources: RawSourceOutput[];
    cache: KeyValueCache;
    hooks: Hooks;
    typeDefs?: DocumentNode[];
    resolvers?: IResolvers;
    transforms: Transform[];
    executor?: Executor;
}) => Promise<GraphQLSchema> | GraphQLSchema;
export declare type RawSourceOutput = {
    name: string;
    contextBuilder: null | ((initialContextValue?: any) => Promise<any>);
    schema: GraphQLSchema;
    executor?: Executor;
    subscriber?: Subscriber;
    transforms: MeshTransform[];
    contextVariables: (keyof any)[];
    handler: MeshHandlerLibrary;
};
