'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

const resolversComposition = require('@graphql-tools/resolvers-composition');
const objectHash = _interopDefault(require('object-hash'));
const utils = require('@graphql-mesh/utils');
const graphqlFields = _interopDefault(require('graphql-fields'));
const schema = require('@graphql-tools/schema');

function computeCacheKey(options) {
    const argsHash = options.args ? objectHash(options.args, { ignoreUnknown: true }) : '';
    const fieldsObj = graphqlFields(options.info);
    const fieldNamesHash = objectHash(fieldsObj, { ignoreUnknown: true });
    if (!options.keyStr) {
        return `${options.info.parentType.name}-${options.info.fieldName}-${argsHash}-${fieldNamesHash}`;
    }
    const templateData = {
        args: options.args,
        argsHash,
        fieldNamesHash,
        info: options.info || null,
    };
    return utils.stringInterpolator.parse(options.keyStr, templateData);
}

class CacheTransform {
    constructor(options) {
        this.options = options;
    }
    transformSchema(schema$1) {
        var _a;
        const { config, hooks, cache } = this.options;
        const sourceResolvers = utils.extractResolvers(schema$1);
        const compositions = {};
        for (const cacheItem of config) {
            const effectingOperations = ((_a = cacheItem.invalidate) === null || _a === void 0 ? void 0 : _a.effectingOperations) || [];
            if (effectingOperations.length > 0) {
                hooks.on('resolverDone', async (resolverInfo) => {
                    const effectingRule = effectingOperations.find(o => o.operation === `${resolverInfo.info.parentType.name}.${resolverInfo.info.fieldName}`);
                    if (effectingRule) {
                        const cacheKey = computeCacheKey({
                            keyStr: effectingRule.matchKey,
                            args: resolverInfo.args,
                            info: resolverInfo.info,
                        });
                        await cache.delete(cacheKey);
                    }
                });
            }
            compositions[cacheItem.field] = (originalResolver => async (root, args, context, info) => {
                var _a;
                const cacheKey = computeCacheKey({
                    keyStr: cacheItem.cacheKey,
                    args,
                    info,
                });
                const cachedValue = await cache.get(cacheKey);
                if (cachedValue) {
                    return cachedValue;
                }
                const resolverResult = await originalResolver(root, args, context, info);
                await cache.set(cacheKey, resolverResult, {
                    ttl: ((_a = cacheItem.invalidate) === null || _a === void 0 ? void 0 : _a.ttl) || undefined,
                });
                return resolverResult;
            });
        }
        const wrappedResolvers = resolversComposition.composeResolvers(sourceResolvers, compositions);
        return schema.addResolversToSchema({
            schema: schema$1,
            resolvers: wrappedResolvers,
            updateResolversInPlace: true,
        });
    }
}

module.exports = CacheTransform;
//# sourceMappingURL=index.cjs.js.map
