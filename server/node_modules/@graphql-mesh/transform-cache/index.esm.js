import { composeResolvers } from '@graphql-tools/resolvers-composition';
import objectHash from 'object-hash';
import { stringInterpolator, extractResolvers } from '@graphql-mesh/utils';
import graphqlFields from 'graphql-fields';
import { addResolversToSchema } from '@graphql-tools/schema';

function computeCacheKey(options) {
    const argsHash = options.args ? objectHash(options.args, { ignoreUnknown: true }) : '';
    const fieldsObj = graphqlFields(options.info);
    const fieldNamesHash = objectHash(fieldsObj, { ignoreUnknown: true });
    if (!options.keyStr) {
        return `${options.info.parentType.name}-${options.info.fieldName}-${argsHash}-${fieldNamesHash}`;
    }
    const templateData = {
        args: options.args,
        argsHash,
        fieldNamesHash,
        info: options.info || null,
    };
    return stringInterpolator.parse(options.keyStr, templateData);
}

class CacheTransform {
    constructor(options) {
        this.options = options;
    }
    transformSchema(schema) {
        var _a;
        const { config, hooks, cache } = this.options;
        const sourceResolvers = extractResolvers(schema);
        const compositions = {};
        for (const cacheItem of config) {
            const effectingOperations = ((_a = cacheItem.invalidate) === null || _a === void 0 ? void 0 : _a.effectingOperations) || [];
            if (effectingOperations.length > 0) {
                hooks.on('resolverDone', async (resolverInfo) => {
                    const effectingRule = effectingOperations.find(o => o.operation === `${resolverInfo.info.parentType.name}.${resolverInfo.info.fieldName}`);
                    if (effectingRule) {
                        const cacheKey = computeCacheKey({
                            keyStr: effectingRule.matchKey,
                            args: resolverInfo.args,
                            info: resolverInfo.info,
                        });
                        await cache.delete(cacheKey);
                    }
                });
            }
            compositions[cacheItem.field] = (originalResolver => async (root, args, context, info) => {
                var _a;
                const cacheKey = computeCacheKey({
                    keyStr: cacheItem.cacheKey,
                    args,
                    info,
                });
                const cachedValue = await cache.get(cacheKey);
                if (cachedValue) {
                    return cachedValue;
                }
                const resolverResult = await originalResolver(root, args, context, info);
                await cache.set(cacheKey, resolverResult, {
                    ttl: ((_a = cacheItem.invalidate) === null || _a === void 0 ? void 0 : _a.ttl) || undefined,
                });
                return resolverResult;
            });
        }
        const wrappedResolvers = composeResolvers(sourceResolvers, compositions);
        return addResolversToSchema({
            schema,
            resolvers: wrappedResolvers,
            updateResolversInPlace: true,
        });
    }
}

export default CacheTransform;
//# sourceMappingURL=index.esm.js.map
