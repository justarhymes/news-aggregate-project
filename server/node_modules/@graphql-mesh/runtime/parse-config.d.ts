import { MeshResolvedSource } from './types';
import { YamlConfig } from '@graphql-mesh/types';
declare global {
    interface ObjectConstructor {
        keys<T>(obj: T): Array<keyof T>;
    }
}
export declare type ConfigProcessOptions = {
    dir?: string;
    ignoreAdditionalResolvers?: boolean;
};
export declare function parseConfig(rawConfig: YamlConfig.Config | string, options?: {
    configFormat?: 'yaml' | 'json' | 'object';
} & ConfigProcessOptions): Promise<{
    sources: MeshResolvedSource<"graphql" | "grpc" | "jsonSchema" | "mongoose" | "mysql" | "neo4j" | "odata" | "openapi" | "postgraphile" | "soap" | "thrift" | "tuql">[];
    transforms: {
        config: string[] | YamlConfig.CacheTransformConfig[] | YamlConfig.FederationTransform | YamlConfig.MockingConfig | YamlConfig.NamingConventionTransformConfig | YamlConfig.PrefixTransformConfig | YamlConfig.RenameTransformObject[] | YamlConfig.ResolversCompositionTransformObject[] | YamlConfig.SnapshotTransformConfig;
        transformLibrary: import("../../types/src").MeshTransformLibrary<string[] | YamlConfig.CacheTransformConfig[] | YamlConfig.FederationTransform | YamlConfig.MockingConfig | YamlConfig.NamingConventionTransformConfig | YamlConfig.PrefixTransformConfig | YamlConfig.RenameTransformObject[] | YamlConfig.ResolversCompositionTransformObject[] | YamlConfig.SnapshotTransformConfig>;
    }[];
    additionalTypeDefs: import("graphql").DocumentNode[];
    additionalResolvers: Record<string, import("@graphql-tools/utils").IUnionTypeResolver | import("@graphql-tools/utils").IScalarTypeResolver | import("@graphql-tools/utils").IEnumTypeResolver | import("@graphql-tools/utils").IInputObjectTypeResolver | import("@graphql-tools/utils").IFieldResolver<any, any, Record<string, any>, any> | import("@graphql-tools/utils").IObjectTypeResolver<any, any, any> | import("@graphql-tools/utils").IInterfaceTypeResolver<any, any, any>>;
    cache: import("fetchache").KeyValueCache<string>;
    merger: import("../../types/src").MergerFn;
    mergerType: string;
}>;
export declare function processConfig(config: YamlConfig.Config, options?: ConfigProcessOptions): Promise<{
    sources: MeshResolvedSource<"graphql" | "grpc" | "jsonSchema" | "mongoose" | "mysql" | "neo4j" | "odata" | "openapi" | "postgraphile" | "soap" | "thrift" | "tuql">[];
    transforms: {
        config: string[] | YamlConfig.CacheTransformConfig[] | YamlConfig.FederationTransform | YamlConfig.MockingConfig | YamlConfig.NamingConventionTransformConfig | YamlConfig.PrefixTransformConfig | YamlConfig.RenameTransformObject[] | YamlConfig.ResolversCompositionTransformObject[] | YamlConfig.SnapshotTransformConfig;
        transformLibrary: import("../../types/src").MeshTransformLibrary<string[] | YamlConfig.CacheTransformConfig[] | YamlConfig.FederationTransform | YamlConfig.MockingConfig | YamlConfig.NamingConventionTransformConfig | YamlConfig.PrefixTransformConfig | YamlConfig.RenameTransformObject[] | YamlConfig.ResolversCompositionTransformObject[] | YamlConfig.SnapshotTransformConfig>;
    }[];
    additionalTypeDefs: import("graphql").DocumentNode[];
    additionalResolvers: Record<string, import("@graphql-tools/utils").IUnionTypeResolver | import("@graphql-tools/utils").IScalarTypeResolver | import("@graphql-tools/utils").IEnumTypeResolver | import("@graphql-tools/utils").IInputObjectTypeResolver | import("@graphql-tools/utils").IFieldResolver<any, any, Record<string, any>, any> | import("@graphql-tools/utils").IObjectTypeResolver<any, any, any> | import("@graphql-tools/utils").IInterfaceTypeResolver<any, any, any>>;
    cache: import("fetchache").KeyValueCache<string>;
    merger: import("../../types/src").MergerFn;
    mergerType: string;
}>;
export declare function validateConfig(config: any): asserts config is YamlConfig.Config;
export declare function findAndParseConfig(options?: {
    configName?: string;
} & ConfigProcessOptions): Promise<{
    sources: MeshResolvedSource<"graphql" | "grpc" | "jsonSchema" | "mongoose" | "mysql" | "neo4j" | "odata" | "openapi" | "postgraphile" | "soap" | "thrift" | "tuql">[];
    transforms: {
        config: string[] | YamlConfig.CacheTransformConfig[] | YamlConfig.FederationTransform | YamlConfig.MockingConfig | YamlConfig.NamingConventionTransformConfig | YamlConfig.PrefixTransformConfig | YamlConfig.RenameTransformObject[] | YamlConfig.ResolversCompositionTransformObject[] | YamlConfig.SnapshotTransformConfig;
        transformLibrary: import("../../types/src").MeshTransformLibrary<string[] | YamlConfig.CacheTransformConfig[] | YamlConfig.FederationTransform | YamlConfig.MockingConfig | YamlConfig.NamingConventionTransformConfig | YamlConfig.PrefixTransformConfig | YamlConfig.RenameTransformObject[] | YamlConfig.ResolversCompositionTransformObject[] | YamlConfig.SnapshotTransformConfig>;
    }[];
    additionalTypeDefs: import("graphql").DocumentNode[];
    additionalResolvers: Record<string, import("@graphql-tools/utils").IUnionTypeResolver | import("@graphql-tools/utils").IScalarTypeResolver | import("@graphql-tools/utils").IEnumTypeResolver | import("@graphql-tools/utils").IInputObjectTypeResolver | import("@graphql-tools/utils").IFieldResolver<any, any, Record<string, any>, any> | import("@graphql-tools/utils").IObjectTypeResolver<any, any, any> | import("@graphql-tools/utils").IInterfaceTypeResolver<any, any, any>>;
    cache: import("fetchache").KeyValueCache<string>;
    merger: import("../../types/src").MergerFn;
    mergerType: string;
}>;
