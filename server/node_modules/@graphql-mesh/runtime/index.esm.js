import { parse, print, Kind, execute, subscribe } from 'graphql';
import { resolve } from 'path';
import { printSchemaWithDirectives, buildOperationNodeForField, applySchemaTransforms } from '@graphql-tools/utils';
import { paramCase } from 'param-case';
import { loadTypedefs } from '@graphql-tools/load';
import { GraphQLFileLoader } from '@graphql-tools/graphql-file-loader';
import { set, get, kebabCase } from 'lodash';
import { stringInterpolator, extractResolvers } from '@graphql-mesh/utils';
import { mergeResolvers } from '@graphql-tools/merge';
import InMemoryLRUCache from '@graphql-mesh/cache-inmemory-lru';
import { composeResolvers } from '@graphql-tools/resolvers-composition';
import { addResolversToSchema } from '@graphql-tools/schema';
import { delegateToSchema } from '@graphql-tools/delegate';
import { EventEmitter } from 'events';
import { defaultLoaders, cosmiconfig } from 'cosmiconfig';
import { getJsonSchema } from '@graphql-mesh/types';
import Ajv from 'ajv';

async function getPackage(name, type) {
    const casedName = paramCase(name);
    const casedType = paramCase(type);
    const possibleNames = [
        `@graphql-mesh/${casedName}`,
        `@graphql-mesh/${casedName}-${casedType}`,
        `@graphql-mesh/${casedType}-${casedName}`,
        casedName,
        `${casedName}-${casedType}`,
        `${casedType}-${casedName}`,
        casedType,
    ];
    const possibleModules = possibleNames.concat(resolve(process.cwd(), name));
    for (const moduleName of possibleModules) {
        try {
            const exported = await import(moduleName);
            return (exported.default || exported.parser || exported);
        }
        catch (err) {
            if (err.message.indexOf(`Cannot find module '${moduleName}'`) === -1) {
                throw new Error(`Unable to load ${type} matching ${name}: ${err.message}`);
            }
        }
    }
    throw new Error(`Unable to find ${type} matching ${name}`);
}
async function getHandler(name) {
    const handlerFn = await getPackage(name, 'handler');
    return handlerFn;
}
async function resolveAdditionalTypeDefs(baseDir, additionalTypeDefs) {
    if (additionalTypeDefs) {
        const sources = await loadTypedefs(additionalTypeDefs, {
            cwd: baseDir,
            loaders: [new GraphQLFileLoader()],
        });
        return sources.map(source => source.document || parse(source.rawSDL || printSchemaWithDirectives(source.schema)));
    }
    return undefined;
}
async function resolveAdditionalResolvers(baseDir, additionalResolvers) {
    const loadedResolvers = await Promise.all((additionalResolvers || []).map(async (additionalResolver) => {
        if (typeof additionalResolver === 'string') {
            const filePath = additionalResolver;
            const exported = await import(resolve(baseDir, filePath));
            let resolvers = null;
            if (exported.default) {
                if (exported.default.resolvers) {
                    resolvers = exported.default.resolvers;
                }
                else if (typeof exported.default === 'object') {
                    resolvers = exported.default;
                }
            }
            else if (exported.resolvers) {
                resolvers = exported.resolvers;
            }
            if (!resolvers) {
                console.warn(`Unable to load resolvers from file: ${filePath}`);
                return {};
            }
            return resolvers;
        }
        else {
            return {
                [additionalResolver.type]: {
                    [additionalResolver.field]: {
                        selectionSet: additionalResolver.requiredSelectionSet,
                        resolve: async (root, args, context, info) => {
                            const resolverData = { root, args, context, info };
                            const methodArgs = {};
                            for (const argPath in additionalResolver.args) {
                                set(methodArgs, argPath, stringInterpolator.parse(additionalResolver.args[argPath], resolverData));
                            }
                            const result = await context[additionalResolver.targetSource].api[additionalResolver.targetMethod](methodArgs, {
                                selectedFields: additionalResolver.resultSelectedFields,
                                selectionSet: additionalResolver.resultSelectionSet,
                                depth: additionalResolver.resultDepth,
                            });
                            return additionalResolver.returnData ? get(result, additionalResolver.returnData) : result;
                        },
                    },
                },
            };
        }
    }));
    return mergeResolvers(loadedResolvers);
}
function ensureDocumentNode(document) {
    return typeof document === 'string' ? parse(document) : document;
}
async function resolveCache(cacheConfig) {
    if (cacheConfig) {
        const cacheName = Object.keys(cacheConfig)[0];
        const config = cacheConfig[cacheName];
        const moduleName = kebabCase(cacheName);
        const pkg = await getPackage(moduleName, 'cache');
        const Cache = pkg.default || pkg;
        return new Cache(config);
    }
    return undefined;
}
async function resolveMerger(mergerConfig) {
    const pkg = await getPackage(mergerConfig || 'stitching', 'merger');
    return pkg.default || pkg;
}

const MESH_CONTEXT_SYMBOL = Symbol('isMeshContext');
const MESH_API_CONTEXT_SYMBOL = Symbol('isMeshAPIContext');

function isMeshContext(context) {
    return !!context && typeof context === 'object' && MESH_CONTEXT_SYMBOL in context;
}
function isAPIContext(apiContext) {
    return !!apiContext && typeof apiContext === 'object' && MESH_API_CONTEXT_SYMBOL in apiContext;
}
function createProxyInfo({ schema, parentType, field, depthLimit = 2, root, args, selectedFields, selectionSet, info, }) {
    const actualReturnType = 'ofType' in info.returnType ? info.returnType.ofType : info.returnType;
    const returnType = 'ofType' in field.type ? field.type.ofType : field.type;
    if (!selectedFields &&
        !selectionSet &&
        'name' in actualReturnType &&
        'name' in returnType &&
        actualReturnType.name === returnType.name) {
        return {
            ...info,
            returnType,
        };
    }
    selectionSet = selectionSet && (typeof selectionSet === 'string' ? parse(selectionSet) : parse(print(selectionSet)));
    const operation = (selectionSet === null || selectionSet === void 0 ? void 0 : selectionSet.definitions[0]) ||
        buildOperationNodeForField({
            schema,
            kind: 'query',
            field: field.name,
            depthLimit,
            argNames: Object.keys(args),
            selectedFields,
        });
    return {
        fieldName: field.name,
        fieldNodes: operation.selectionSet.selections.filter(s => s.kind === Kind.FIELD),
        returnType: field.type,
        parentType,
        schema,
        fragments: {},
        rootValue: root,
        operation,
        variableValues: args,
        path: {
            key: field.name,
        },
    };
}
function applyResolversHooksToResolvers(unifiedSchema, resolvers, hooks) {
    return composeResolvers(resolvers, {
        '*.*': originalResolver => async (root, args, context = {}, info) => {
            const resolverData = {
                root,
                args,
                context,
                info,
            };
            hooks.emit('resolverCalled', resolverData);
            try {
                const proxyContext = new Proxy(context, {
                    get(context, apiName) {
                        if (isMeshContext(context)) {
                            const apiContext = context[apiName];
                            if (isAPIContext(apiContext)) {
                                const sdk = new Proxy(apiContext, {
                                    get(apiContext, fieldName) {
                                        const apiSchema = unifiedSchema.extensions.sourceMap.get(apiContext.rawSource);
                                        const rootTypes = {
                                            query: apiSchema.getQueryType(),
                                            mutation: apiSchema.getMutationType(),
                                            subscription: apiSchema.getSubscriptionType(),
                                        };
                                        let parentType;
                                        let operation;
                                        let field;
                                        for (const operationName in rootTypes) {
                                            const rootType = rootTypes[operationName];
                                            if (rootType) {
                                                const fieldMap = rootType.getFields();
                                                if (fieldName in fieldMap) {
                                                    operation = operationName;
                                                    field = fieldMap[fieldName];
                                                    parentType = rootType;
                                                }
                                            }
                                        }
                                        return (methodArgs = {}, { depth, fields, selectionSet } = {}) => {
                                            const proxyInfo = createProxyInfo({
                                                schema: apiSchema,
                                                parentType,
                                                field,
                                                depthLimit: depth,
                                                root,
                                                args: methodArgs,
                                                selectedFields: fields,
                                                selectionSet,
                                                info,
                                            });
                                            return delegateToSchema({
                                                schema: apiSchema,
                                                operation,
                                                fieldName,
                                                args: methodArgs,
                                                context,
                                                info: proxyInfo,
                                            });
                                        };
                                    },
                                });
                                return {
                                    ...apiContext,
                                    api: sdk,
                                };
                            }
                        }
                        return context[apiName];
                    },
                });
                const result = await originalResolver(root, args, proxyContext, info);
                hooks.emit('resolverDone', resolverData, result);
                return result;
            }
            catch (e) {
                hooks.emit('resolverError', resolverData, e);
                throw e;
            }
        },
    });
}
function applyResolversHooksToSchema(schema, hooks) {
    const sourceResolvers = extractResolvers(schema);
    return addResolversToSchema({
        schema,
        resolvers: applyResolversHooksToResolvers(schema, sourceResolvers, hooks),
        updateResolversInPlace: true,
    });
}

/* eslint-disable no-unused-expressions */
function groupTransforms({ transforms, apiName, cache, hooks, }) {
    const wrapTransforms = [];
    const noWrapTransforms = [];
    transforms === null || transforms === void 0 ? void 0 : transforms.forEach(({ transformLibrary: TransformCtor, config }) => {
        const transform = new TransformCtor({
            apiName,
            config,
            cache,
            hooks,
        });
        if (transform.noWrap) {
            noWrapTransforms.push(transform);
        }
        else {
            wrapTransforms.push(transform);
        }
    });
    return { wrapTransforms, noWrapTransforms };
}
async function getMesh(options) {
    const rawSources = [];
    let hooks = options.hooks;
    if (!hooks) {
        hooks = new EventEmitter({ captureRejections: true });
        hooks.setMaxListeners(Infinity);
    }
    const cache = options.cache || new InMemoryLRUCache();
    await Promise.all(options.sources.map(async (apiSource) => {
        const source = await apiSource.handlerLibrary.getMeshSource({
            name: apiSource.name,
            config: apiSource.handlerConfig || {},
            hooks,
            cache,
        });
        let apiSchema = source.schema;
        const apiName = apiSource.name;
        const { wrapTransforms, noWrapTransforms } = groupTransforms({
            transforms: apiSource.transforms,
            apiName,
            cache,
            hooks,
        });
        apiSchema = applySchemaTransforms(apiSchema, noWrapTransforms);
        rawSources.push({
            name: apiName,
            contextBuilder: source.contextBuilder || null,
            schema: apiSchema,
            executor: source.executor,
            subscriber: source.subscriber,
            transforms: wrapTransforms,
            contextVariables: source.contextVariables || [],
            handler: apiSource.handlerLibrary,
        });
    }));
    let unifiedSchema = await options.merger({
        rawSources,
        cache,
        hooks,
        typeDefs: options.additionalTypeDefs,
        resolvers: options.additionalResolvers,
        transforms: options.transforms.map(({ transformLibrary: TransformCtor, config }) => new TransformCtor({
            config,
            cache,
            hooks,
        })),
    });
    hooks.emit('schemaReady', unifiedSchema);
    unifiedSchema = applyResolversHooksToSchema(unifiedSchema, hooks);
    async function buildMeshContext(initialContextValue) {
        const context = {
            ...initialContextValue,
            [MESH_CONTEXT_SYMBOL]: true,
        };
        await Promise.all(rawSources.map(async (rawSource) => {
            const contextBuilder = rawSource.contextBuilder;
            if (contextBuilder) {
                const sourceContext = await contextBuilder(context);
                if (sourceContext) {
                    Object.assign(context, sourceContext);
                }
            }
            Object.assign(context, {
                [rawSource.name]: {
                    rawSource,
                    [MESH_API_CONTEXT_SYMBOL]: true,
                },
            });
        }));
        return context;
    }
    async function meshExecute(document, variables, context, rootValue) {
        const contextValue = await buildMeshContext(context);
        return execute({
            document: ensureDocumentNode(document),
            contextValue,
            rootValue: rootValue || {},
            variableValues: variables || {},
            schema: unifiedSchema,
        });
    }
    async function meshSubscribe(document, variables, context, rootValue) {
        const contextValue = await buildMeshContext(context);
        return subscribe({
            document: ensureDocumentNode(document),
            contextValue,
            rootValue: rootValue || {},
            variableValues: variables || {},
            schema: unifiedSchema,
        });
    }
    const localRequester = async (document, variables, context) => {
        const executionResult = await meshExecute(document, variables, context);
        if (executionResult.data && !executionResult.errors) {
            return executionResult.data;
        }
        else {
            throw new GraphQLMeshSdkError(executionResult.errors, document, variables, executionResult.data);
        }
    };
    return {
        execute: meshExecute,
        subscribe: meshSubscribe,
        schema: unifiedSchema,
        contextBuilder: buildMeshContext,
        rawSources,
        sdkRequester: localRequester,
        cache,
        hooks,
        destroy: () => hooks.emit('destroy'),
    };
}
class GraphQLMeshSdkError extends Error {
    constructor(errors, document, variables, data) {
        super(`GraphQL Mesh SDK Failed (${errors.length} errors): ${errors.map(e => e.message).join('\n\t')}`);
        this.errors = errors;
        this.document = document;
        this.variables = variables;
        this.data = data;
        errors.forEach(e => console.error(e));
    }
}

async function parseConfig(rawConfig, options) {
    let config;
    const { configFormat = 'object' } = options || {};
    switch (configFormat) {
        case 'yaml':
            config = defaultLoaders['.yaml']('.meshrc.yml', rawConfig);
            break;
        case 'json':
            config = defaultLoaders['.json']('.meshrc.json', rawConfig);
            break;
        case 'object':
            config = rawConfig;
            break;
    }
    return processConfig(config, options);
}
async function processConfig(config, options) {
    var _a, _b;
    const { dir = process.cwd(), ignoreAdditionalResolvers = false } = options || {};
    await Promise.all(((_a = config.require) === null || _a === void 0 ? void 0 : _a.map(mod => import(mod))) || []);
    const [sources, transforms, additionalTypeDefs, additionalResolvers, cache, merger] = await Promise.all([
        Promise.all(config.sources.map(async (source) => {
            const handlerName = Object.keys(source.handler)[0];
            const handlerConfig = source.handler[handlerName];
            const [handlerLibrary, transforms] = await Promise.all([
                getHandler(handlerName),
                Promise.all((source.transforms || []).map(async (t) => {
                    const transformName = Object.keys(t)[0];
                    const transformConfig = t[transformName];
                    const transformLibrary = await getPackage(transformName, 'transform');
                    return {
                        config: transformConfig,
                        transformLibrary,
                    };
                })),
            ]);
            return {
                name: source.name,
                handlerConfig,
                handlerLibrary,
                transforms,
            };
        })),
        Promise.all(((_b = config.transforms) === null || _b === void 0 ? void 0 : _b.map(async (t) => {
            const transformName = Object.keys(t)[0];
            const transformConfig = t[transformName];
            const TransformLibrary = await getPackage(transformName, 'transform');
            return {
                config: transformConfig,
                transformLibrary: TransformLibrary,
            };
        })) || []),
        resolveAdditionalTypeDefs(dir, config.additionalTypeDefs),
        resolveAdditionalResolvers(dir, ignoreAdditionalResolvers ? [] : config.additionalResolvers || []),
        resolveCache(config.cache),
        resolveMerger(config.merger),
    ]);
    return {
        sources,
        transforms,
        additionalTypeDefs,
        additionalResolvers,
        cache,
        merger,
        mergerType: config.merger,
    };
}
function customLoader(ext) {
    function loader(filepath, content) {
        if (typeof process !== 'undefined' && 'env' in process) {
            content = content.replace(/\$\{(.*?)\}/g, (_, variable) => {
                let varName = variable;
                let defaultValue = '';
                if (variable.includes(':')) {
                    const spl = variable.split(':');
                    varName = spl.shift();
                    defaultValue = spl.join(':');
                }
                return process.env[varName] || defaultValue;
            });
        }
        if (ext === 'json') {
            return defaultLoaders['.json'](filepath, content);
        }
        if (ext === 'yaml') {
            return defaultLoaders['.yaml'](filepath, content);
        }
        if (ext === 'js') {
            return defaultLoaders['.js'](filepath, content);
        }
    }
    return loader;
}
function validateConfig(config) {
    const ajv = new Ajv({ schemaId: 'auto' });
    // Settings for draft-04
    const metaSchema = require('ajv/lib/refs/json-schema-draft-04.json');
    ajv.addMetaSchema(metaSchema);
    const isValid = ajv.validate(getJsonSchema(), config);
    if (!isValid) {
        throw new Error(`GraphQL Mesh Configuration is not valid: ${ajv.errorsText()}`);
    }
}
async function findAndParseConfig(options) {
    const { configName = 'mesh', dir = process.cwd(), ignoreAdditionalResolvers = false } = options || {};
    const explorer = cosmiconfig(configName, {
        loaders: {
            '.json': customLoader('json'),
            '.yaml': customLoader('yaml'),
            '.yml': customLoader('yaml'),
            '.js': customLoader('js'),
            noExt: customLoader('yaml'),
        },
    });
    const results = await explorer.search(dir);
    const config = results === null || results === void 0 ? void 0 : results.config;
    validateConfig(config);
    return processConfig(config, { dir, ignoreAdditionalResolvers });
}

export { GraphQLMeshSdkError, applyResolversHooksToResolvers, applyResolversHooksToSchema, ensureDocumentNode, findAndParseConfig, getHandler, getMesh, getPackage, groupTransforms, parseConfig, processConfig, resolveAdditionalResolvers, resolveAdditionalTypeDefs, resolveCache, resolveMerger, validateConfig };
//# sourceMappingURL=index.esm.js.map
