import { readFileOrUrlWithCache, getInterpolatedHeadersFactory, getHeadersObject, parseInterpolationStrings } from '@graphql-mesh/utils';
import { GraphQLError, GraphQLObjectType, GraphQLInputObjectType, GraphQLUnionType, GraphQLList, GraphQLEnumType, GraphQLBoolean, GraphQLFloat, GraphQLInt, GraphQLString, GraphQLID, GraphQLNonNull, GraphQLSchema } from 'graphql';
import { convertObj } from 'swagger2openapi';
import { validate } from 'oas-validator';
import debug, { debug as debug$1 } from 'debug';
import { singular } from 'pluralize';
import { JSONPath } from 'jsonpath-plus';
import formurlencoded from 'form-urlencoded';
import urlJoin from 'url-join';
import deepEqual from 'deep-equal';
import { GraphQLJSON } from 'graphql-scalars';
import { fetchache, Request } from 'fetchache';

// Copyright IBM Corp. 2018. All Rights Reserved.
// Node module: openapi-to-graphql
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
const mitigations = {
    /**
     * Problems with the OAS
     *
     * Should be caught by the module oas-validator
     */
    INVALID_OAS: `Ignore issue and continue.`,
    UNNAMED_PARAMETER: `Ignore parameter.`,
    // General problems
    AMBIGUOUS_UNION_MEMBERS: `Ignore issue and continue.`,
    CANNOT_GET_FIELD_TYPE: `Ignore field and continue.`,
    COMBINE_SCHEMAS: `Ignore combine schema keyword and continue.`,
    DUPLICATE_FIELD_NAME: `Ignore field and maintain preexisting field.`,
    DUPLICATE_LINK_KEY: `Ignore link and maintain preexisting link.`,
    MISSING_RESPONSE_SCHEMA: `Ignore operation.`,
    MISSING_SCHEMA: `Use arbitrary JSON type.`,
    MULTIPLE_RESPONSES: `Select first response object with successful status code (200-299).`,
    NON_APPLICATION_JSON_SCHEMA: `Ignore schema`,
    OBJECT_MISSING_PROPERTIES: `The (sub-)object will be stored in an arbitray JSON type.`,
    UNKNOWN_TARGET_TYPE: `The response will be stored in an arbitrary JSON type.`,
    UNRESOLVABLE_SCHEMA: `Ignore and continue. May lead to unexpected behavior.`,
    UNSUPPORTED_HTTP_SECURITY_SCHEME: `Ignore security scheme.`,
    UNSUPPORTED_JSON_SCHEMA_KEYWORD: `Ignore keyword and continue.`,
    // Links
    AMBIGUOUS_LINK: `Use first occurance of '#/'.`,
    LINK_NAME_COLLISION: `Ignore link and maintain preexisting field.`,
    UNRESOLVABLE_LINK: `Ignore link.`,
    // Multiple OAS
    DUPLICATE_OPERATIONID: `Ignore operation and maintain preexisting operation.`,
    DUPLICATE_SECURITY_SCHEME: `Ignore security scheme and maintain preexisting scheme.`,
    MULTIPLE_OAS_SAME_TITLE: `Ignore issue and continue.`,
    // Options
    CUSTOM_RESOLVER_UNKNOWN_OAS: `Ignore this set of custom resolvers.`,
    CUSTOM_RESOLVER_UNKNOWN_PATH_METHOD: `Ignore this set of custom resolvers.`,
    LIMIT_ARGUMENT_NAME_COLLISION: `Do not override existing 'limit' argument.`,
    // Miscellaneous
    OAUTH_SECURITY_SCHEME: `Ignore security scheme`,
};
/**
 * Utilities that are specific to OpenAPI-to-GraphQL
 */
function handleWarning({ typeKey, message, mitigationAddendum, path, data, log, }) {
    const mitigation = mitigations[typeKey];
    const warning = {
        type: typeKey,
        message,
        mitigation: mitigationAddendum ? `${mitigation} ${mitigationAddendum}` : mitigation,
    };
    if (typeof path !== 'undefined') {
        warning.path = path;
    }
    if (data.options.strict) {
        throw new Error(`${warning.type} - ${warning.message}`);
    }
    else {
        const output = `Warning: ${warning.message} - ${warning.mitigation}`;
        if (typeof log === 'function') {
            log(output);
        }
        else {
            console.warn(output);
        }
        data.options.report.warnings.push(warning);
    }
}
// Code provided by codename- from StackOverflow
// Link: https://stackoverflow.com/a/29622653
function sortObject(o) {
    return (Object.keys(o)
        .sort()
        // eslint-disable-next-line no-sequences
        .reduce((r, k) => ((r[k] = o[k]), r), {}));
}
/**
 * Finds the common property names between two objects
 */
function getCommonPropertyNames(object1, object2) {
    return Object.keys(object1).filter(propertyName => {
        return propertyName in object2;
    });
}

/* eslint-disable no-use-before-define */
const httpLog = debug('http');
const preprocessingLog = debug('preprocessing');
const translationLog = debug('translation');
// OAS constants
const OAS_OPERATIONS = ['get', 'put', 'post', 'patch', 'delete', 'options', 'head'];
const SUCCESS_STATUS_RX = /2[0-9]{2}|2XX/;
/**
 * Resolves on a validated OAS 3 for the given spec (OAS 2 or OAS 3), or rejects
 * if errors occur.
 */
async function getValidOAS3(spec, options) {
    // CASE: translate
    if (typeof spec.swagger === 'string' && spec.swagger === '2.0') {
        preprocessingLog(`Received OpenAPI Specification 2.0 - going to translate...`);
        const result = await convertObj(spec, {});
        return result.openapi;
        // CASE: validate
    }
    else if (typeof spec.openapi === 'string' && /^3/.test(spec.openapi)) {
        if (!options.skipSchemaValidation) {
            preprocessingLog(`Received OpenAPI Specification 3.0.x - going to validate...`);
            const valid = await validate(spec, {});
            if (!valid) {
                throw new Error(`Validation of OpenAPI Specification failed.`);
            }
            preprocessingLog(`OpenAPI Specification is validated`);
        }
        return spec;
    }
    else {
        throw new Error(`Invalid specification provided`);
    }
}
/**
 * Counts the number of operations in an OAS.
 */
function countOperations(oas) {
    let numOps = 0;
    for (const path in oas.paths) {
        for (const method in oas.paths[path]) {
            if (isOperation(method)) {
                numOps++;
            }
        }
    }
    return numOps;
}
/**
 * Counts the number of operations that translate to queries in an OAS.
 */
function countOperationsQuery(oas) {
    let numOps = 0;
    for (const path in oas.paths) {
        for (const method in oas.paths[path]) {
            if (isOperation(method) && method.toLowerCase() === 'get') {
                numOps++;
            }
        }
    }
    return numOps;
}
/**
 * Counts the number of operations that translate to mutations in an OAS.
 */
function countOperationsMutation(oas) {
    let numOps = 0;
    for (const path in oas.paths) {
        for (const method in oas.paths[path]) {
            if (isOperation(method) && method.toLowerCase() !== 'get') {
                numOps++;
            }
        }
    }
    return numOps;
}
/**
 * Resolves the given reference in the given object.
 */
function resolveRef(ref, oas) {
    // Break path into individual tokens
    const parts = ref.split('/');
    const resolvedObject = resolveRefHelper(oas, parts);
    if (resolvedObject !== null) {
        return resolvedObject;
    }
    else {
        throw new Error(`Could not resolve reference '${ref}'`);
    }
}
/**
 * Helper for resolveRef
 *
 * @param parts The path to be resolved, but broken into tokens
 */
function resolveRefHelper(obj, parts) {
    if (parts.length === 0) {
        return obj;
    }
    const firstElement = parts.splice(0, 1)[0];
    if (firstElement in obj) {
        return resolveRefHelper(obj[firstElement], parts);
    }
    else if (firstElement === '#') {
        return resolveRefHelper(obj, parts);
    }
    else {
        return null;
    }
}
/**
 * Returns the base URL to use for the given operation.
 */
function getBaseUrl(operation) {
    // Check for servers:
    if (!Array.isArray(operation.servers) || operation.servers.length === 0) {
        throw new Error(`No servers defined for operation '${operation.operationString}'`);
    }
    // Check for local servers
    if (Array.isArray(operation.servers) && operation.servers.length > 0) {
        const url = buildUrl(operation.servers[0]);
        if (Array.isArray(operation.servers) && operation.servers.length > 1) {
            httpLog(`Warning: Randomly selected first server '${url}'`);
        }
        return url.replace(/\/$/, '');
    }
    const oas = operation.oas;
    if (Array.isArray(oas.servers) && oas.servers.length > 0) {
        const url = buildUrl(oas.servers[0]);
        if (Array.isArray(oas.servers) && oas.servers.length > 1) {
            httpLog(`Warning: Randomly selected first server '${url}'`);
        }
        return url.replace(/\/$/, '');
    }
    throw new Error('Cannot find a server to call');
}
/**
 * Returns the default URL for a given OAS server object.
 */
function buildUrl(server) {
    let url = server.url;
    // Replace with variable defaults, if applicable
    if (typeof server.variables === 'object' && Object.keys(server.variables).length > 0) {
        for (const variableKey in server.variables) {
            // TODO: check for default? Would be invalid OAS
            url = url.replace(`{${variableKey}}`, server.variables[variableKey].default.toString());
        }
    }
    return url;
}
/**
 * Returns object/array/scalar where all object keys (if applicable) are
 * sanitized.
 */
function sanitizeObjectKeys(obj, // obj does not necessarily need to be an object
caseStyle = CaseStyle.camelCase) {
    const cleanKeys = (obj) => {
        // Case: no (response) data
        if (obj === null || typeof obj === 'undefined') {
            return null;
            // Case: array
        }
        else if (Array.isArray(obj)) {
            return obj.map(cleanKeys);
            // Case: object
        }
        else if (typeof obj === 'object') {
            const res = {};
            for (const key in obj) {
                const saneKey = sanitize(key, caseStyle);
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    res[saneKey] = cleanKeys(obj[key]);
                }
            }
            return res;
            // Case: scalar
        }
        else {
            return obj;
        }
    };
    return cleanKeys(obj);
}
/**
 * Desanitizes keys in given object by replacing them with the keys stored in
 * the given mapping.
 */
function desanitizeObjectKeys(obj, mapping = {}) {
    const replaceKeys = (obj) => {
        if (obj === null) {
            return null;
        }
        else if (Array.isArray(obj)) {
            return obj.map(replaceKeys);
        }
        else if (typeof obj === 'object') {
            const res = {};
            for (const key in obj) {
                if (key in mapping) {
                    const rawKey = mapping[key];
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        res[rawKey] = replaceKeys(obj[key]);
                    }
                }
                else {
                    res[key] = replaceKeys(obj[key]);
                }
            }
            return res;
        }
        else {
            return obj;
        }
    };
    return replaceKeys(obj);
}
/**
 * Replaces the path parameter in the given path with values in the given args.
 * Furthermore adds the query parameters for a request.
 */
function instantiatePathAndGetQuery(path, parameters, args, // NOTE: argument keys are sanitized!
data) {
    const query = {};
    const headers = {};
    // Case: nothing to do
    if (Array.isArray(parameters)) {
        // Iterate parameters:
        for (const param of parameters) {
            const sanitizedParamName = sanitize(param.name, !data.options.simpleNames ? CaseStyle.camelCase : CaseStyle.simple);
            if (sanitizedParamName && sanitizedParamName in args) {
                switch (param.in) {
                    // Path parameters
                    case 'path':
                        path = path.replace(`{${param.name}}`, args[sanitizedParamName]);
                        break;
                    // Query parameters
                    case 'query':
                        query[param.name] = args[sanitizedParamName];
                        break;
                    // Header parameters
                    case 'header':
                        headers[param.name] = args[sanitizedParamName];
                        break;
                    // Cookie parameters
                    case 'cookie':
                        if (!('cookie' in headers)) {
                            headers.cookie = '';
                        }
                        headers.cookie += `${param.name}=${args[sanitizedParamName]}; `;
                        break;
                    default:
                        httpLog(`Warning: The parameter location '${param.in}' in the ` +
                            `parameter '${param.name}' of operation '${path}' is not ` +
                            `supported`);
                }
            }
            else {
                httpLog(`Warning: The parameter '${param.name}' of operation '${path}' ` + `could not be found`);
            }
        }
    }
    return { path, query, headers };
}
/**
 * Returns the GraphQL type that the provided schema should be made into
 *
 * Does not consider allOf, anyOf, oneOf, or not (handled separately)
 */
function getSchemaTargetGraphQLType(schema, data) {
    // CASE: object
    if (schema.type === 'object' || typeof schema.properties === 'object') {
        // TODO: additionalProperties is more like a flag than a type itself
        // CASE: arbitrary JSON
        if (typeof schema.additionalProperties === 'object') {
            return 'json';
        }
        else {
            return 'object';
        }
    }
    // CASE: array
    if (schema.type === 'array' || 'items' in schema) {
        return 'list';
    }
    // CASE: enum
    if (Array.isArray(schema.enum)) {
        return 'enum';
    }
    // CASE: a type is present
    if (typeof schema.type === 'string') {
        // Special edge cases involving the schema format
        if (typeof schema.format === 'string') {
            /**
             * CASE: 64 bit int - return number instead of integer, leading to use of
             * GraphQLFloat, which can support 64 bits:
             */
            if (schema.type === 'integer' && schema.format === 'int64') {
                return 'number';
                // CASE: id
            }
            else if (schema.type === 'string' &&
                (schema.format === 'uuid' ||
                    // Custom ID format
                    (Array.isArray(data.options.idFormats) && data.options.idFormats.includes(schema.format)))) {
                return 'id';
            }
        }
        return schema.type;
    }
    return null;
}
function isIdParam(part) {
    return /^{.*(id|name|key).*}$/gi.test(part);
}
function isSingularParam(part, nextPart) {
    // eslint-disable-next-line no-useless-escape
    return `\{${singular(part)}\}` === nextPart;
}
/**
 * Infers a resource name from the given URL path.
 *
 * For example, turns "/users/{userId}/car" into "userCar".
 */
function inferResourceNameFromPath(path) {
    const parts = path.split('/');
    const pathNoPathParams = parts.reduce((path, part, i) => {
        if (!/{/g.test(part)) {
            if (parts[i + 1] && (isIdParam(parts[i + 1]) || isSingularParam(part, parts[i + 1]))) {
                return path + capitalize(singular(part));
            }
            else {
                return path + capitalize(part);
            }
        }
        else {
            return path;
        }
    }, '');
    return pathNoPathParams;
}
/**
 * Returns JSON-compatible schema required by the given endpoint - or null if it
 * does not exist.
 */
function getRequestBodyObject(endpoint, oas) {
    if (typeof endpoint.requestBody === 'object') {
        let requestBodyObject = endpoint.requestBody;
        // Make sure we have a RequestBodyObject:
        if (typeof requestBodyObject.$ref === 'string') {
            requestBodyObject = resolveRef(requestBodyObject.$ref, oas);
        }
        else {
            requestBodyObject = requestBodyObject;
        }
        if (typeof requestBodyObject.content === 'object') {
            const content = requestBodyObject.content;
            // Prioritize content-type JSON
            if (Object.keys(content).includes('application/json')) {
                return {
                    payloadContentType: 'application/json',
                    requestBodyObject,
                };
            }
            else if (Object.keys(content).includes('application/x-www-form-urlencoded')) {
                return {
                    payloadContentType: 'application/x-www-form-urlencoded',
                    requestBodyObject,
                };
            }
            else {
                // Pick first (random) content type
                const randomContentType = Object.keys(content)[0].toString();
                return {
                    payloadContentType: randomContentType,
                    requestBodyObject,
                };
            }
        }
    }
    return { payloadContentType: null, requestBodyObject: null };
}
/**
 * Returns the request schema (if any) for an endpoint at given path and method,
 * a dictionary of names from different sources (if available), and whether the
 * request schema is required for the endpoint.
 */
function getRequestSchemaAndNames(path, method, oas) {
    const endpoint = oas.paths[path][method];
    const { payloadContentType, requestBodyObject } = getRequestBodyObject(endpoint, oas);
    if (payloadContentType) {
        let payloadSchema = requestBodyObject.content[payloadContentType].schema;
        // Get resource name from different sources
        let fromRef;
        if ('$ref' in payloadSchema) {
            fromRef = payloadSchema.$ref.split('/').pop();
            payloadSchema = resolveRef(payloadSchema.$ref, oas);
        }
        let payloadSchemaNames = {
            fromRef,
            fromSchema: payloadSchema.title,
            fromPath: inferResourceNameFromPath(path),
        };
        // Determine if request body is required:
        const payloadRequired = typeof requestBodyObject.required === 'boolean' ? requestBodyObject.required : false;
        /**
         * Edge case: if request body content-type is not application/json or
         * application/x-www-form-urlencoded, do not parse it.
         *
         * Instead, treat the request body as a black box and send it as a string
         * with the proper content-type header
         */
        if (payloadContentType !== 'application/json' && payloadContentType !== 'application/x-www-form-urlencoded') {
            const saneContentTypeName = uncapitalize(payloadContentType.split('/').reduce((name, term) => {
                return name + capitalize(term);
            }));
            payloadSchemaNames = {
                fromPath: saneContentTypeName,
            };
            let description = `String represents payload of content type '${payloadContentType}'`;
            if ('description' in payloadSchema && typeof payloadSchema.description === 'string') {
                description += `\n\nOriginal top level description: '${payloadSchema.description}'`;
            }
            payloadSchema = {
                description: description,
                type: 'string',
            };
        }
        return {
            payloadContentType,
            payloadSchema,
            payloadSchemaNames,
            payloadRequired,
        };
    }
    return {
        payloadRequired: false,
    };
}
/**
 * Returns JSON-compatible schema produced by the given endpoint - or null if it
 * does not exist.
 */
function getResponseObject(endpoint, statusCode, oas) {
    if (typeof endpoint.responses === 'object') {
        const responses = endpoint.responses;
        if (typeof responses[statusCode] === 'object') {
            let responseObject = responses[statusCode];
            // Make sure we have a ResponseObject:
            if (typeof responseObject.$ref === 'string') {
                responseObject = resolveRef(responseObject.$ref, oas);
            }
            else {
                responseObject = responseObject;
            }
            if (responseObject.content && typeof responseObject.content !== 'undefined') {
                const content = responseObject.content;
                // Prioritize content-type JSON
                if (Object.keys(content).includes('application/json')) {
                    return {
                        responseContentType: 'application/json',
                        responseObject,
                    };
                }
                else {
                    // Pick first (random) content type
                    const randomContentType = Object.keys(content)[0].toString();
                    return {
                        responseContentType: randomContentType,
                        responseObject,
                    };
                }
            }
        }
    }
    return { responseContentType: null, responseObject: null };
}
/**
 * Returns the response schema for endpoint at given path and method and with
 * the given status code, and a dictionary of names from different sources (if
 * available).
 */
function getResponseSchemaAndNames(path, method, oas, data, options) {
    const endpoint = oas.paths[path][method];
    const statusCode = getResponseStatusCode(path, method, oas, data);
    if (!statusCode) {
        return {};
    }
    const { responseContentType, responseObject } = getResponseObject(endpoint, statusCode, oas);
    if (responseContentType) {
        let responseSchema = responseObject.content[responseContentType].schema;
        let fromRef;
        if ('$ref' in responseSchema) {
            fromRef = responseSchema.$ref.split('/').pop();
            responseSchema = resolveRef(responseSchema.$ref, oas);
        }
        const responseSchemaNames = {
            fromRef,
            fromSchema: responseSchema.title,
            fromPath: inferResourceNameFromPath(path),
        };
        /**
         * Edge case: if response body content-type is not application/json, do not
         * parse.
         */
        if (responseContentType !== 'application/json') {
            let description = 'Placeholder to access non-application/json response bodies';
            if ('description' in responseSchema && typeof responseSchema.description === 'string') {
                description += `\n\nOriginal top level description: '${responseSchema.description}'`;
            }
            responseSchema = {
                description: description,
                type: 'string',
            };
        }
        return {
            responseContentType,
            responseSchema,
            responseSchemaNames,
            statusCode,
        };
    }
    else {
        /**
         * GraphQL requires that objects must have some properties.
         *
         * To allow some operations (such as those with a 204 HTTP code) to be
         * included in the GraphQL interface, we added the fillEmptyResponses
         * option, which will simply create a placeholder to allow access.
         */
        if (options.fillEmptyResponses) {
            return {
                responseSchemaNames: {
                    fromPath: inferResourceNameFromPath(path),
                },
                responseContentType: 'application/json',
                responseSchema: {
                    description: 'Placeholder to support operations with no response schema',
                    type: 'string',
                },
            };
        }
        return {};
    }
}
/**
 * Returns the success status code for the operation at the given path and
 * method (or null).
 */
function getResponseStatusCode(path, method, oas, data) {
    const endpoint = oas.paths[path][method];
    if (typeof endpoint.responses === 'object') {
        const codes = Object.keys(endpoint.responses);
        const successCodes = codes.filter(code => {
            return SUCCESS_STATUS_RX.test(code) || code === 'default';
        });
        if (successCodes.length === 1) {
            return successCodes[0];
        }
        else if (successCodes.length > 1) {
            handleWarning({
                typeKey: 'MULTIPLE_RESPONSES',
                message: `Operation '${formatOperationString(method, path, oas.info.title)}' ` +
                    `contains multiple possible successful response object ` +
                    `(HTTP code 200-299 or 2XX). Only one can be chosen.`,
                mitigationAddendum: `The response object with the HTTP code ` + `${successCodes[0]} will be selected`,
                data,
                log: translationLog,
            });
            return successCodes[0];
        }
    }
    return null;
}
/**
 * Returns an hash containing the links defined in the given endpoint.
 */
function getEndpointLinks(path, method, oas, data) {
    const links = {};
    const endpoint = oas.paths[path][method];
    const statusCode = getResponseStatusCode(path, method, oas, data);
    if (!statusCode) {
        return links;
    }
    if (typeof endpoint.responses === 'object') {
        const responses = endpoint.responses;
        if (typeof responses[statusCode] === 'object') {
            let response = responses[statusCode];
            if (typeof response.$ref === 'string') {
                response = resolveRef(response.$ref, oas);
            }
            // Here, we can be certain we have a ResponseObject:
            response = response;
            if (typeof response.links === 'object') {
                const epLinks = response.links;
                for (const linkKey in epLinks) {
                    let link = epLinks[linkKey];
                    // Make sure we have LinkObjects:
                    if (typeof link.$ref === 'string') {
                        link = resolveRef(link.$ref, oas);
                    }
                    else {
                        link = link;
                    }
                    links[linkKey] = link;
                }
            }
        }
    }
    return links;
}
/**
 * Returns the list of parameters for the endpoint at the given method and path.
 * Resolves possible references.
 */
function getParameters(path, method, oas) {
    let parameters = [];
    if (!isOperation(method)) {
        translationLog(`Warning: attempted to get parameters for ${method} ${path}, ` + `which is not an operation.`);
        return parameters;
    }
    const pathItemObject = oas.paths[path];
    const pathParams = pathItemObject.parameters;
    // First, consider parameters in Path Item Object:
    if (Array.isArray(pathParams)) {
        const pathItemParameters = pathParams.map(p => {
            if (typeof p.$ref === 'string') {
                // Here we know we have a parameter object:
                return resolveRef(p.$ref, oas);
            }
            else {
                // Here we know we have a parameter object:
                return p;
            }
        });
        parameters = parameters.concat(pathItemParameters);
    }
    // Second, consider parameters in Operation Object:
    const opObject = oas.paths[path][method];
    const opObjectParameters = opObject.parameters;
    if (Array.isArray(opObjectParameters)) {
        const opParameters = opObjectParameters.map(p => {
            if (typeof p.$ref === 'string') {
                // Here we know we have a parameter object:
                return resolveRef(p.$ref, oas);
            }
            else {
                // Here we know we have a parameter object:
                return p;
            }
        });
        parameters = parameters.concat(opParameters);
    }
    return parameters;
}
/**
 * Returns an array of server objects for the opeartion at the given path and
 * method. Considers in the following order: global server definitions,
 * definitions at the path item, definitions at the operation, or the OAS
 * default.
 */
function getServers(path, method, oas) {
    let servers = [];
    // Global server definitions:
    if (Array.isArray(oas.servers) && oas.servers.length > 0) {
        servers = oas.servers;
    }
    // Path item server definitions override global:
    const pathItem = oas.paths[path];
    if (Array.isArray(pathItem.servers) && pathItem.servers.length > 0) {
        servers = pathItem.servers;
    }
    // Operation server definitions override path item:
    const operationObj = pathItem[method];
    if (Array.isArray(operationObj.servers) && operationObj.servers.length > 0) {
        servers = operationObj.servers;
    }
    // Default, in case there is no server:
    if (servers.length === 0) {
        const server = {
            url: '/',
        };
        servers.push(server);
    }
    return servers;
}
/**
 * Returns a map of Security Scheme definitions, identified by keys. Resolves
 * possible references.
 */
function getSecuritySchemes(oas) {
    // Collect all security schemes:
    const securitySchemes = {};
    if (typeof oas.components === 'object' && typeof oas.components.securitySchemes === 'object') {
        for (const schemeKey in oas.components.securitySchemes) {
            const obj = oas.components.securitySchemes[schemeKey];
            // Ensure we have actual SecuritySchemeObject:
            if (typeof obj.$ref === 'string') {
                // Result of resolution will be SecuritySchemeObject:
                securitySchemes[schemeKey] = resolveRef(obj.$ref, oas);
            }
            else {
                // We already have a SecuritySchemeObject:
                securitySchemes[schemeKey] = obj;
            }
        }
    }
    return securitySchemes;
}
/**
 * Returns the list of sanitized keys of non-OAuth2 security schemes
 * required by the operation at the given path and method.
 */
function getSecurityRequirements(path, method, securitySchemes, oas) {
    const results = [];
    // First, consider global requirements:
    const globalSecurity = oas.security;
    if (globalSecurity && typeof globalSecurity !== 'undefined') {
        for (const secReq of globalSecurity) {
            for (const schemaKey in secReq) {
                if (securitySchemes[schemaKey] &&
                    typeof securitySchemes[schemaKey] === 'object' &&
                    securitySchemes[schemaKey].def.type !== 'oauth2') {
                    results.push(schemaKey);
                }
            }
        }
    }
    // Local:
    const operation = oas.paths[path][method];
    const localSecurity = operation.security;
    if (localSecurity && typeof localSecurity !== 'undefined') {
        for (const secReq of localSecurity) {
            for (const schemaKey in secReq) {
                if (securitySchemes[schemaKey] &&
                    typeof securitySchemes[schemaKey] === 'object' &&
                    securitySchemes[schemaKey].def.type !== 'oauth2') {
                    if (!results.includes(schemaKey)) {
                        results.push(schemaKey);
                    }
                }
            }
        }
    }
    return results;
}
var CaseStyle;
(function (CaseStyle) {
    CaseStyle[CaseStyle["simple"] = 0] = "simple";
    CaseStyle[CaseStyle["PascalCase"] = 1] = "PascalCase";
    CaseStyle[CaseStyle["camelCase"] = 2] = "camelCase";
    CaseStyle[CaseStyle["ALL_CAPS"] = 3] = "ALL_CAPS";
})(CaseStyle || (CaseStyle = {}));
/**
 * First sanitizes given string and then also camel-cases it.
 */
function sanitize(str, caseStyle) {
    /**
     * Used in conjunction to simpleNames, which only removes illegal
     * characters and preserves casing
     */
    if (caseStyle === CaseStyle.simple) {
        return str.replace(/[^a-zA-Z0-9_]/gi, '');
    }
    /**
     * Remove all GraphQL unsafe characters
     */
    const regex = caseStyle === CaseStyle.ALL_CAPS
        ? /[^a-zA-Z0-9_]/g // ALL_CAPS has underscores
        : /[^a-zA-Z0-9]/g;
    let sanitized = str.split(regex).reduce((path, part) => {
        if (caseStyle === CaseStyle.ALL_CAPS) {
            return path + '_' + part;
        }
        else {
            return path + capitalize(part);
        }
    });
    switch (caseStyle) {
        case CaseStyle.PascalCase:
            // The first character in PascalCase should be uppercase
            sanitized = capitalize(sanitized);
            break;
        case CaseStyle.camelCase:
            // The first character in camelCase should be lowercase
            sanitized = uncapitalize(sanitized);
            break;
        case CaseStyle.ALL_CAPS:
            sanitized = sanitized.toUpperCase();
            break;
    }
    // Special case: we cannot start with number, and cannot be empty:
    if (/^[0-9]/.test(sanitized) || sanitized === '') {
        sanitized = '_' + sanitized;
    }
    return sanitized;
}
/**
 * Sanitizes the given string and stores the sanitized-to-original mapping in
 * the given mapping.
 */
function storeSaneName(saneStr, str, mapping) {
    if (saneStr in mapping && str !== mapping[saneStr]) {
        // TODO: Follow warning model
        translationLog(`Warning: '${str}' and '${mapping[saneStr]}' both sanitize ` +
            `to '${saneStr}' - collision possible. Desanitize to '${str}'.`);
    }
    mapping[saneStr] = str;
    return saneStr;
}
/**
 * Stringifies and possibly trims the given string to the provided length.
 */
function trim(str, length) {
    if (typeof str !== 'string') {
        str = JSON.stringify(str);
    }
    if (str && str.length > length) {
        str = `${str.substring(0, length)}...`;
    }
    return str;
}
/**
 * Determines if the given "method" is indeed an operation. Alternatively, the
 * method could point to other types of information (e.g., parameters, servers).
 */
function isOperation(method) {
    return OAS_OPERATIONS.includes(method.toLowerCase());
}
/**
 * Formats a string that describes an operation in the form:
 * {name of OAS} {HTTP method in ALL_CAPS} {operation path}
 *
 * Also used in preprocessing.ts where Operation objects are being constructed
 */
function formatOperationString(method, path, title) {
    if (title) {
        return `${title} ${method.toUpperCase()} ${path}`;
    }
    else {
        return `${method.toUpperCase()} ${path}`;
    }
}
/**
 * Capitalizes a given string
 */
function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
/**
 * Uncapitalizes a given string
 */
function uncapitalize(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
}
/**
 * For operations that do not have an operationId, generate one
 */
function generateOperationId(method, path) {
    return sanitize(`${method} ${path}`, CaseStyle.camelCase);
}

/* eslint-disable no-case-declarations */
const translationLog$1 = debug$1('translation');
const httpLog$1 = debug$1('http');
function headersToObject(headers) {
    const headersObj = {};
    headers.forEach((value, key) => {
        headersObj[key] = value;
    });
    return headersObj;
}
/**
 * Creates and returns a resolver function that performs API requests for the
 * given GraphQL query
 */
function getResolver(getResolverParams) {
    let { operation, argsFromLink = {}, payloadName, data, baseUrl, requestOptions } = getResolverParams();
    // Determine the appropriate URL:
    if (typeof baseUrl === 'undefined') {
        baseUrl = getBaseUrl(operation);
    }
    // Return custom resolver if it is defined
    const customResolvers = data.options.customResolvers;
    const title = operation.oas.info.title;
    const path = operation.path;
    const method = operation.method;
    if (typeof customResolvers === 'object' &&
        typeof customResolvers[title] === 'object' &&
        typeof customResolvers[title][path] === 'object' &&
        typeof customResolvers[title][path][method] === 'function') {
        translationLog$1(`Use custom resolver for ${operation.operationString}`);
        return customResolvers[title][path][method];
    }
    // Return resolve function:
    return async (root, args, ctx, info = {}) => {
        /**
         * Retch resolveData from possibly existing _openAPIToGraphQL
         *
         * NOTE: _openAPIToGraphQL is an object used to pass security info and data
         * from previous resolvers
         */
        let resolveData = {};
        if (root &&
            typeof root === 'object' &&
            typeof root._openAPIToGraphQL === 'object' &&
            typeof root._openAPIToGraphQL.data === 'object') {
            const parentIdentifier = getParentIdentifier(info);
            if (!(parentIdentifier.length === 0) && parentIdentifier in root._openAPIToGraphQL.data) {
                /**
                 * Resolving link params may change the usedParams, but these changes
                 * should not be present in the parent _openAPIToGraphQL, therefore copy
                 * the object
                 */
                resolveData = JSON.parse(JSON.stringify(root._openAPIToGraphQL.data[parentIdentifier]));
            }
        }
        if (typeof resolveData.usedParams === 'undefined') {
            resolveData.usedParams = {};
        }
        /**
         * Handle default values of parameters, if they have not yet been defined by
         * the user.
         */
        operation.parameters.forEach(param => {
            const paramName = sanitize(param.name, !data.options.simpleNames ? CaseStyle.camelCase : CaseStyle.simple);
            if (typeof args[paramName] === 'undefined' && param.schema && typeof param.schema === 'object') {
                let schema = param.schema;
                if (schema && schema.$ref && typeof schema.$ref === 'string') {
                    schema = resolveRef(schema.$ref, operation.oas);
                }
                if (schema && schema.default && typeof schema.default !== 'undefined') {
                    args[paramName] = schema.default;
                }
            }
        });
        // Handle arguments provided by links
        for (const paramName in argsFromLink) {
            const saneParamName = sanitize(paramName, !data.options.simpleNames ? CaseStyle.camelCase : CaseStyle.simple);
            let value = argsFromLink[paramName];
            /**
             * see if the link parameter contains constants that are appended to the link parameter
             *
             * e.g. instead of:
             * $response.body#/employerId
             *
             * it could be:
             * abc_{$response.body#/employerId}
             */
            if (value.search(/{|}/) === -1) {
                args[saneParamName] = isRuntimeExpression(value)
                    ? resolveLinkParameter(paramName, value, resolveData, root)
                    : value;
            }
            else {
                // Replace link parameters with appropriate values
                const linkParams = value.match(/{([^}]*)}/g);
                linkParams.forEach(linkParam => {
                    value = value.replace(linkParam, resolveLinkParameter(paramName, linkParam.substring(1, linkParam.length - 1), resolveData, root));
                });
                args[saneParamName] = value;
            }
        }
        // Stored used parameters to future requests:
        resolveData.usedParams = Object.assign(resolveData.usedParams, args);
        // Build URL (i.e., fill in path parameters):
        const { path, query, headers } = instantiatePathAndGetQuery(operation.path, operation.parameters, args, data);
        const urlObject = new URL(urlJoin(baseUrl, path));
        /**
         * The Content-type and accept property should not be changed because the
         * object type has already been created and unlike these properties, it
         * cannot be easily changed
         *
         * NOTE: This may cause the user to encounter unexpected changes
         */
        headers['content-type'] =
            typeof operation.payloadContentType !== 'undefined' ? operation.payloadContentType : 'application/json';
        headers.accept =
            typeof operation.responseContentType !== 'undefined' ? operation.responseContentType : 'application/json';
        let options;
        if (requestOptions) {
            options = { ...requestOptions };
            options.method = operation.method;
            if (options.headers) {
                Object.assign(options.headers, headers);
            }
            else {
                options.headers = headers;
            }
        }
        else {
            options = {
                method: operation.method,
                headers: headers,
            };
        }
        for (const paramName in query) {
            const val = query[paramName];
            urlObject.searchParams.set(paramName, val);
        }
        /**
         * Determine possible payload
         *
         * GraphQL produces sanitized payload names, so we have to sanitize before
         * lookup here
         */
        resolveData.usedPayload = undefined;
        if (typeof payloadName === 'string') {
            // The option genericPayloadArgName will change the payload name to "requestBody"
            const sanePayloadName = data.options.genericPayloadArgName
                ? 'requestBody'
                : sanitize(payloadName, CaseStyle.camelCase);
            let rawPayload;
            if (operation.payloadContentType === 'application/json') {
                rawPayload = JSON.stringify(desanitizeObjectKeys(args[sanePayloadName], data.saneMap));
            }
            else if (operation.payloadContentType === 'application/x-www-form-urlencoded') {
                rawPayload = formurlencoded(desanitizeObjectKeys(args[sanePayloadName], data.saneMap));
            }
            else {
                // Payload is not an object
                rawPayload = args[sanePayloadName];
            }
            options.body = rawPayload;
            resolveData.usedPayload = rawPayload;
        }
        /**
         * Pass on OpenAPI-to-GraphQL options
         */
        if (typeof data.options === 'object') {
            // Headers:
            if (typeof data.options.headers === 'object') {
                for (const header in data.options.headers) {
                    const val = data.options.headers[header];
                    options.headers[header] = val;
                }
            }
            // Query string:
            if (typeof data.options.qs === 'object') {
                for (const query in data.options.qs) {
                    const val = data.options.qs[query];
                    urlObject.searchParams.set(query, val);
                }
            }
        }
        // Get authentication headers and query parameters
        if (root && typeof root === 'object' && typeof root._openAPIToGraphQL === 'object') {
            const { authHeaders, authQs, authCookie } = getAuthOptions(operation, root._openAPIToGraphQL, data);
            // ...and pass them to the options
            Object.assign(options.headers, authHeaders);
            for (const query in authQs) {
                const val = authQs[query];
                urlObject.searchParams.set(query, val);
            }
            // Add authentication cookie if created
            if (authCookie !== null) {
                Object.assign(options.headers, {
                    cookie: authCookie,
                });
            }
        }
        // Extract OAuth token from context (if available)
        if (data.options.sendOAuthTokenInQuery) {
            const oauthQueryObj = createOAuthQS(data, ctx);
            for (const query in oauthQueryObj) {
                const val = oauthQueryObj[query];
                urlObject.searchParams.set(query, val);
            }
        }
        else {
            const oauthHeader = createOAuthHeader(data, ctx);
            Object.assign(options.headers, oauthHeader);
        }
        const urlWithoutQuery = urlObject.href.replace(urlObject.search, '');
        resolveData.url = urlWithoutQuery;
        resolveData.usedRequestOptions = options;
        resolveData.usedStatusCode = operation.statusCode;
        // Make the call
        httpLog$1(`Call ${options.method.toUpperCase()} ${urlWithoutQuery}?${urlObject.search}\n` +
            `headers: ${JSON.stringify(options.headers)}\n` +
            `request body: ${options.body}`);
        let response;
        try {
            response = await data.options.fetch(urlObject.href, options);
        }
        catch (err) {
            httpLog$1(err);
            throw err;
        }
        const body = await response.text();
        if (response.status < 200 || response.status > 299) {
            httpLog$1(`${response.status} - ${trim(body, 100)}`);
            const errorString = `Could not invoke operation ${operation.operationString}`;
            if (data.options.provideErrorExtensions) {
                let responseBody;
                try {
                    responseBody = JSON.parse(body);
                }
                catch (e) {
                    responseBody = body;
                }
                const extensions = {
                    method: operation.method,
                    path: operation.path,
                    statusCode: response.status,
                    responseHeaders: headersToObject(response.headers),
                    responseBody,
                };
                throw graphQLErrorWithExtensions(errorString, extensions);
            }
            else {
                throw new Error(errorString);
            }
            // Successful response 200-299
        }
        else {
            httpLog$1(`${response.status} - ${trim(body, 100)}`);
            if (response.headers.get('content-type')) {
                /**
                 * If the response body is type JSON, then parse it
                 *
                 * content-type may not be necessarily 'application/json' it can be
                 * 'application/json; charset=utf-8' for example
                 */
                if (response.headers.get('content-type').includes('json')) {
                    let responseBody;
                    try {
                        responseBody = JSON.parse(body);
                    }
                    catch (e) {
                        const errorString = `Cannot JSON parse response body of ` +
                            `operation ${operation.operationString} ` +
                            `even though it has content-type '${response.headers.get('content-type')}'`;
                        httpLog$1(errorString);
                        throw errorString;
                    }
                    resolveData.responseHeaders = headersToObject(response.headers);
                    // Deal with the fact that the server might send unsanitized data
                    let saneData = sanitizeObjectKeys(responseBody, !data.options.simpleNames ? CaseStyle.camelCase : CaseStyle.simple);
                    // Pass on _openAPIToGraphQL to subsequent resolvers
                    if (saneData && typeof saneData === 'object') {
                        if (Array.isArray(saneData)) {
                            saneData.forEach(element => {
                                if (typeof element._openAPIToGraphQL === 'undefined') {
                                    element._openAPIToGraphQL = {
                                        data: {},
                                    };
                                }
                                if (root && typeof root === 'object' && typeof root._openAPIToGraphQL === 'object') {
                                    Object.assign(element._openAPIToGraphQL, root._openAPIToGraphQL);
                                }
                                element._openAPIToGraphQL.data[getIdentifier(info)] = resolveData;
                            });
                        }
                        else {
                            if (typeof saneData._openAPIToGraphQL === 'undefined') {
                                saneData._openAPIToGraphQL = {
                                    data: {},
                                };
                            }
                            if (root && typeof root === 'object' && typeof root._openAPIToGraphQL === 'object') {
                                Object.assign(saneData._openAPIToGraphQL, root._openAPIToGraphQL);
                            }
                            saneData._openAPIToGraphQL.data[getIdentifier(info)] = resolveData;
                        }
                    }
                    // Apply limit argument
                    if (data.options.addLimitArgument &&
                        /**
                         * NOTE: Does not differentiate between autogenerated args and
                         * preexisting args
                         *
                         * Ensure that there is not preexisting 'limit' argument
                         */
                        !operation.parameters.find(parameter => {
                            return parameter.name === 'limit';
                        }) &&
                        // Only array data
                        Array.isArray(saneData) &&
                        // Only array of objects/arrays
                        saneData.some(data => {
                            return typeof data === 'object';
                        })) {
                        let arraySaneData = saneData;
                        if ('limit' in args) {
                            const limit = args.limit;
                            if (limit >= 0) {
                                arraySaneData = arraySaneData.slice(0, limit);
                            }
                            else {
                                throw new Error(`Auto-generated 'limit' argument must be greater than or equal to 0`);
                            }
                        }
                        else {
                            throw new Error(`Cannot get value for auto-generated 'limit' argument`);
                        }
                        saneData = arraySaneData;
                    }
                    return saneData;
                }
                else {
                    // TODO: Handle YAML
                    return body;
                }
            }
            else {
                /**
                 * Check to see if there is not supposed to be a response body,
                 * if that is the case, that would explain why there is not
                 * a content-type
                 */
                const { responseContentType } = getResponseObject(operation, operation.statusCode, operation.oas);
                if (responseContentType === null) {
                    return null;
                }
                else {
                    const errorString = 'Response does not have a Content-Type property';
                    httpLog$1(errorString);
                    throw errorString;
                }
            }
        }
    };
}
/**
 * Attempts to create an object to become an OAuth query string by extracting an
 * OAuth token from the ctx based on the JSON path provided in the options.
 */
function createOAuthQS(data, ctx) {
    return typeof data.options.tokenJSONpath !== 'string' ? {} : extractToken(data, ctx);
}
function extractToken(data, ctx) {
    const tokenJSONpath = data.options.tokenJSONpath;
    const tokens = JSONPath({ path: tokenJSONpath, json: ctx });
    if (Array.isArray(tokens) && tokens.length > 0) {
        const token = tokens[0];
        return {
            access_token: token,
        };
    }
    else {
        httpLog$1(`Warning: could not extract OAuth token from context at '${tokenJSONpath}'`);
        return {};
    }
}
/**
 * Attempts to create an OAuth authorization header by extracting an OAuth token
 * from the ctx based on the JSON path provided in the options.
 */
function createOAuthHeader(data, ctx) {
    if (typeof data.options.tokenJSONpath !== 'string') {
        return {};
    }
    // Extract token
    const tokenJSONpath = data.options.tokenJSONpath;
    const tokens = JSONPath({ path: tokenJSONpath, json: ctx });
    if (Array.isArray(tokens) && tokens.length > 0) {
        const token = tokens[0];
        return {
            Authorization: `Bearer ${token}`,
            'User-Agent': 'openapi-to-graphql',
        };
    }
    else {
        httpLog$1(`Warning: could not extract OAuth token from context at ` + `'${tokenJSONpath}'`);
        return {};
    }
}
/**
 * Returns the headers and query strings to authenticate a request (if any).
 * Object containing authHeader and authQs object,
 * which hold headers and query parameters respectively to authentication a
 * request.
 */
function getAuthOptions(operation, _openAPIToGraphQL, data) {
    const authHeaders = {};
    const authQs = {};
    let authCookie = null;
    /**
     * Determine if authentication is required, and which protocol (if any) we can
     * use
     */
    const { authRequired, sanitizedSecurityRequirement } = getAuthReqAndProtcolName(operation, _openAPIToGraphQL);
    const securityRequirement = data.saneMap[sanitizedSecurityRequirement];
    // Possibly, we don't need to do anything:
    if (!authRequired) {
        return { authHeaders, authQs, authCookie };
    }
    // If authentication is required, but we can't fulfill the protocol, throw:
    if (authRequired && typeof securityRequirement !== 'string') {
        throw new Error(`Missing information to authenticate API request.`);
    }
    if (typeof securityRequirement === 'string') {
        const security = data.security[securityRequirement];
        switch (security.def.type) {
            case 'apiKey':
                const apiKey = _openAPIToGraphQL.security[sanitizedSecurityRequirement].apiKey;
                if ('in' in security.def) {
                    if (typeof security.def.name === 'string') {
                        if (security.def.in === 'header') {
                            authHeaders[security.def.name] = apiKey;
                        }
                        else if (security.def.in === 'query') {
                            authQs[security.def.name] = apiKey;
                        }
                        else if (security.def.in === 'cookie') {
                            authCookie = `${security.def.name}=${apiKey}`;
                        }
                    }
                    else {
                        throw new Error(`Cannot send API key in '${JSON.stringify(security.def.in)}'`);
                    }
                }
                break;
            case 'http':
                switch (security.def.scheme) {
                    case 'basic':
                        const username = _openAPIToGraphQL.security[sanitizedSecurityRequirement].username;
                        const password = _openAPIToGraphQL.security[sanitizedSecurityRequirement].password;
                        const credentials = `${username}:${password}`;
                        authHeaders.Authorization = `Basic ${Buffer.from(credentials).toString('base64')}`;
                        break;
                    default:
                        throw new Error(`Cannot recognize http security scheme ` + `'${JSON.stringify(security.def.scheme)}'`);
                }
                break;
            case 'oauth2':
                break;
            case 'openIdConnect':
                break;
            default:
                throw new Error(`Cannot recognize security type '${security.def.type}'`);
        }
    }
    return { authHeaders, authQs, authCookie };
}
/**
 * Determines whether given operation requires authentication, and which of the
 * (possibly multiple) authentication protocols can be used based on the data
 * present in the given context.
 */
function getAuthReqAndProtcolName(operation, _openAPIToGraphQL) {
    let authRequired = false;
    if (Array.isArray(operation.securityRequirements) && operation.securityRequirements.length > 0) {
        authRequired = true;
        for (const securityRequirement of operation.securityRequirements) {
            const sanitizedSecurityRequirement = sanitize(securityRequirement, CaseStyle.camelCase);
            if (typeof _openAPIToGraphQL.security[sanitizedSecurityRequirement] === 'object') {
                return {
                    authRequired,
                    sanitizedSecurityRequirement,
                };
            }
        }
    }
    return {
        authRequired,
    };
}
/**
 * Given a link parameter, determine the value
 *
 * The link parameter is a reference to data contained in the
 * url/method/statuscode or response/request body/query/path/header
 */
function resolveLinkParameter(paramName, value, resolveData, root, args) {
    if (value === '$url') {
        return resolveData.url;
    }
    else if (value === '$method') {
        return resolveData.usedRequestOptions.method;
    }
    else if (value === '$statusCode') {
        return resolveData.usedStatusCode;
    }
    else if (value.startsWith('$request.')) {
        // CASE: parameter is previous body
        if (value === '$request.body') {
            return resolveData.usedPayload;
            // CASE: parameter in previous body
        }
        else if (value.startsWith('$request.body#')) {
            const tokens = JSONPath({
                path: value.split('body#/')[1],
                json: resolveData.usedPayload,
            });
            if (Array.isArray(tokens) && tokens.length > 0) {
                return tokens[0];
            }
            else {
                httpLog$1(`Warning: could not extract parameter '${paramName}' from link`);
            }
            // CASE: parameter in previous query parameter
        }
        else if (value.startsWith('$request.query')) {
            return resolveData.usedParams[sanitize(value.split('query.')[1], CaseStyle.camelCase)];
            // CASE: parameter in previous path parameter
        }
        else if (value.startsWith('$request.path')) {
            return resolveData.usedParams[sanitize(value.split('path.')[1], CaseStyle.camelCase)];
            // CASE: parameter in previous header parameter
        }
        else if (value.startsWith('$request.header')) {
            return resolveData.usedRequestOptions.headers[value.split('header.')[1]];
        }
    }
    else if (value.startsWith('$response.')) {
        /**
         * CASE: parameter is body
         *
         * NOTE: may not be used because it implies that the operation does not
         * return a JSON object and OpenAPI-to-GraphQL does not create GraphQL
         * objects for non-JSON data and links can only exists between objects.
         */
        if (value === '$response.body') {
            const result = JSON.parse(JSON.stringify(root));
            /**
             * _openAPIToGraphQL contains data used by OpenAPI-to-GraphQL to create the GraphQL interface
             * and should not be exposed
             */
            result._openAPIToGraphQL = undefined;
            return result;
            // CASE: parameter in body
        }
        else if (value.startsWith('$response.body#')) {
            const tokens = JSONPath({
                path: value.split('body#/')[1],
                json: root,
            });
            if (Array.isArray(tokens) && tokens.length > 0) {
                return tokens[0];
            }
            else {
                httpLog$1(`Warning: could not extract parameter '${paramName}' from link`);
            }
            // CASE: parameter in query parameter
        }
        else if (value.startsWith('$response.query')) {
            // NOTE: handled the same way $request.query is handled
            return resolveData.usedParams[sanitize(value.split('query.')[1], CaseStyle.camelCase)];
            // CASE: parameter in path parameter
        }
        else if (value.startsWith('$response.path')) {
            // NOTE: handled the same way $request.path is handled
            return resolveData.usedParams[sanitize(value.split('path.')[1], CaseStyle.camelCase)];
            // CASE: parameter in header parameter
        }
        else if (value.startsWith('$response.header')) {
            return resolveData.responseHeaders[value.split('header.')[1]];
        }
    }
    throw new Error(`Cannot create link because '${value}' is an invalid runtime expression`);
}
/**
 * Check if a string is a runtime expression in the context of link parameters
 */
function isRuntimeExpression(str) {
    const references = ['header.', 'query.', 'path.', 'body'];
    if (str === '$url' || str === '$method' || str === '$statusCode') {
        return true;
    }
    else if (str.startsWith('$request.')) {
        for (let i = 0; i < references.length; i++) {
            if (str.startsWith(`$request.${references[i]}`)) {
                return true;
            }
        }
    }
    else if (str.startsWith('$response.')) {
        for (let i = 0; i < references.length; i++) {
            if (str.startsWith(`$response.${references[i]}`)) {
                return true;
            }
        }
    }
    return false;
}
/**
 * From the info object provided by the resolver, get a unique identifier, which
 * is the path formed from the nested field names (or aliases if provided)
 *
 * Used to store and retrieve the _openAPIToGraphQL of parent field
 */
function getIdentifier(info) {
    return getIdentifierRecursive(info.path);
}
/**
 * From the info object provided by the resolver, get the unique identifier of
 * the parent object
 */
function getParentIdentifier(info) {
    return getIdentifierRecursive(info.path.prev);
}
/**
 * Get the path of nested field names (or aliases if provided)
 */
function getIdentifierRecursive(path) {
    return typeof path.prev === 'undefined'
        ? path.key.toString()
        : /**
         * Check if the identifier contains array indexing, if so remove.
         *
         * i.e. instead of 0/friends/1/friends/2/friends/user, create
         * friends/friends/friends/user
         */
            isNaN(parseInt(path.key.toString()))
                ? `${path.key}/${getIdentifierRecursive(path.prev)}`
                : getIdentifierRecursive(path.prev);
}
/**
 * Create a new GraphQLError with an extensions field
 */
function graphQLErrorWithExtensions(message, extensions) {
    return new GraphQLError(message, null, null, null, null, null, extensions);
}

// Copyright IBM Corp. 2018. All Rights Reserved.
// Node module: openapi-to-graphql
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
var GraphQLOperationType;
(function (GraphQLOperationType) {
    GraphQLOperationType[GraphQLOperationType["Query"] = 0] = "Query";
    GraphQLOperationType[GraphQLOperationType["Mutation"] = 1] = "Mutation";
    // TODO: Subscription
})(GraphQLOperationType || (GraphQLOperationType = {}));

// Copyright IBM Corp. 2018. All Rights Reserved.
const preprocessingLog$1 = debug('preprocessing');
/**
 * Extract information from the OAS and put it inside a data structure that
 * is easier for OpenAPI-to-GraphQL to use
 */
function preprocessOas(oass, options) {
    const data = {
        usedTypeNames: [
            'Query',
            'Mutation',
        ],
        defs: [],
        operations: {},
        saneMap: {},
        security: {},
        options,
        oass,
    };
    oass.forEach(oas => {
        // Store stats on OAS:
        data.options.report.numOps += countOperations(oas);
        data.options.report.numOpsMutation += countOperationsMutation(oas);
        data.options.report.numOpsQuery += countOperationsQuery(oas);
        // Get security schemes
        const currentSecurity = getProcessedSecuritySchemes(oas, data);
        const commonSecurityPropertyName = getCommonPropertyNames(data.security, currentSecurity);
        commonSecurityPropertyName.forEach(propertyName => {
            handleWarning({
                typeKey: 'DUPLICATE_SECURITY_SCHEME',
                message: `Multiple OASs share security schemes with the same name '${propertyName}'`,
                mitigationAddendum: `The security scheme from OAS ` + `'${currentSecurity[propertyName].oas.info.title}' will be ignored`,
                data,
                log: preprocessingLog$1,
            });
        });
        // Do not overwrite preexisting security schemes
        data.security = { ...currentSecurity, ...data.security };
        // Process all operations
        for (const path in oas.paths) {
            for (const method in oas.paths[path]) {
                // Only consider Operation Objects
                if (!isOperation(method)) {
                    continue;
                }
                const endpoint = oas.paths[path][method];
                const operationString = oass.length === 1
                    ? formatOperationString(method, path)
                    : formatOperationString(method, path, oas.info.title);
                // Determine description
                let description = endpoint.description;
                if ((typeof description !== 'string' || description === '') && typeof endpoint.summary === 'string') {
                    description = endpoint.summary;
                }
                if (data.options.equivalentToMessages) {
                    // Description may not exist
                    if (typeof description !== 'string') {
                        description = '';
                    }
                    description += `\n\nEquivalent to ${operationString}`;
                }
                // Hold on to the operationId
                const operationId = typeof endpoint.operationId !== 'undefined'
                    ? endpoint.operationId
                    : generateOperationId(method, path);
                // Request schema
                const { payloadContentType, payloadSchema, payloadSchemaNames, payloadRequired, } = getRequestSchemaAndNames(path, method, oas);
                const payloadDefinition = payloadSchema && typeof payloadSchema !== 'undefined'
                    ? createDataDef(payloadSchemaNames, payloadSchema, true, data, undefined, oas)
                    : undefined;
                // Response schema
                const { responseContentType, responseSchema, responseSchemaNames, statusCode, } = getResponseSchemaAndNames(path, method, oas, data, options);
                if (!responseSchema || typeof responseSchema !== 'object') {
                    handleWarning({
                        typeKey: 'MISSING_RESPONSE_SCHEMA',
                        message: `Operation ${operationString} has no (valid) response schema. ` +
                            `You can use the fillEmptyResponses option to create a ` +
                            `placeholder schema`,
                        data,
                        log: preprocessingLog$1,
                    });
                    continue;
                }
                // Links
                const links = getEndpointLinks(path, method, oas, data);
                const responseDefinition = createDataDef(responseSchemaNames, responseSchema, false, data, links, oas);
                // Parameters
                const parameters = getParameters(path, method, oas);
                // Security protocols
                const securityRequirements = options.viewer
                    ? getSecurityRequirements(path, method, data.security, oas)
                    : [];
                // Servers
                const servers = getServers(path, method, oas);
                // Whether to place this operation into an authentication viewer
                const inViewer = securityRequirements.length > 0 && data.options.viewer !== false;
                /**
                 * Whether the operation should be added as a Query or Mutation field.
                 * By default, all GET operations are Query fields and all other
                 * operations are Mutation fields.
                 */
                let isMutation = method.toLowerCase() !== 'get';
                // Option selectQueryOrMutationField can override isMutation
                if (typeof options.selectQueryOrMutationField === 'object' &&
                    typeof options.selectQueryOrMutationField[oas.info.title] === 'object' &&
                    typeof options.selectQueryOrMutationField[oas.info.title][path] === 'object' &&
                    typeof options.selectQueryOrMutationField[oas.info.title][path][method] === 'number' // This is an TS enum, which is translated to have a integer value
                ) {
                    isMutation =
                        options.selectQueryOrMutationField[oas.info.title][path][method] === GraphQLOperationType.Mutation;
                }
                // Store determined information for operation
                const operation = {
                    operationId,
                    operationString,
                    description,
                    path,
                    method: method.toLowerCase(),
                    payloadContentType,
                    payloadDefinition,
                    payloadRequired,
                    responseContentType,
                    responseDefinition,
                    parameters,
                    securityRequirements,
                    servers,
                    inViewer,
                    isMutation,
                    statusCode,
                    oas,
                };
                /**
                 * Handle operationId property name collision
                 * May occur if multiple OAS are provided
                 */
                if (operationId in data.operations) {
                    handleWarning({
                        typeKey: 'DUPLICATE_OPERATIONID',
                        message: `Multiple OASs share operations with the same operationId '${operationId}'`,
                        mitigationAddendum: `The operation from the OAS '${operation.oas.info.title}' will be ignored`,
                        data,
                        log: preprocessingLog$1,
                    });
                }
                else {
                    data.operations[operationId] = operation;
                }
            }
        }
    });
    return data;
}
/**
 * Extracts the security schemes from given OAS and organizes the information in
 * a data structure that is easier for OpenAPI-to-GraphQL to use
 *
 * Here is the structure of the data:
 * {
 *   {string} [sanitized name] { Contains information about the security protocol
 *     {string} rawName           Stores the raw security protocol name
 *     {object} def               Definition provided by OAS
 *     {object} parameters        Stores the names of the authentication credentials
 *                                  NOTE: Structure will depend on the type of the protocol
 *                                    (e.g. basic authentication, API key, etc.)
 *                                  NOTE: Mainly used for the AnyAuth viewers
 *     {object} schema            Stores the GraphQL schema to create the viewers
 *   }
 * }
 *
 * Here is an example:
 * {
 *   MyApiKey: {
 *     rawName: "My_api_key",
 *     def: { ... },
 *     parameters: {
 *       apiKey: MyKeyApiKey
 *     },
 *     schema: { ... }
 *   }
 *   MyBasicAuth: {
 *     rawName: "My_basic_auth",
 *     def: { ... },
 *     parameters: {
 *       username: MyBasicAuthUsername,
 *       password: MyBasicAuthPassword,
 *     },
 *     schema: { ... }
 *   }
 * }
 */
function getProcessedSecuritySchemes(oas, data) {
    const result = {};
    const security = getSecuritySchemes(oas);
    // Loop through all the security protocols
    for (const key in security) {
        const protocol = security[key];
        // Determine the schema and the parameters for the security protocol
        let schema;
        let parameters = {};
        let description;
        switch (protocol.type) {
            case 'apiKey':
                description = `API key credentials for the security protocol '${key}'`;
                if (data.oass.length > 1) {
                    description += ` in ${oas.info.title}`;
                }
                parameters = {
                    apiKey: sanitize(`${key}_apiKey`, CaseStyle.camelCase),
                };
                schema = {
                    type: 'object',
                    description,
                    properties: {
                        apiKey: {
                            type: 'string',
                        },
                    },
                };
                break;
            case 'http':
                switch (protocol.scheme) {
                    /**
                     * TODO: HTTP has a number of authentication types
                     *
                     * See http://www.iana.org/assignments/http-authschemes/http-authschemes.xhtml
                     */
                    case 'basic':
                        description = `Basic auth credentials for security protocol '${key}'`;
                        parameters = {
                            username: sanitize(`${key}_username`, CaseStyle.camelCase),
                            password: sanitize(`${key}_password`, CaseStyle.camelCase),
                        };
                        schema = {
                            type: 'object',
                            description,
                            properties: {
                                username: {
                                    type: 'string',
                                },
                                password: {
                                    type: 'string',
                                },
                            },
                        };
                        break;
                    default:
                        handleWarning({
                            typeKey: 'UNSUPPORTED_HTTP_SECURITY_SCHEME',
                            message: `Currently unsupported HTTP authentication protocol ` +
                                `type 'http' and scheme '${protocol.scheme}' in OAS ` +
                                `'${oas.info.title}'`,
                            data,
                            log: preprocessingLog$1,
                        });
                }
                break;
            // TODO: Implement
            case 'openIdConnect':
                handleWarning({
                    typeKey: 'UNSUPPORTED_HTTP_SECURITY_SCHEME',
                    message: `Currently unsupported HTTP authentication protocol ` + `type 'openIdConnect' in OAS '${oas.info.title}'`,
                    data,
                    log: preprocessingLog$1,
                });
                break;
            case 'oauth2':
                handleWarning({
                    typeKey: 'OAUTH_SECURITY_SCHEME',
                    message: `OAuth security scheme found in OAS '${oas.info.title}'. ` +
                        `OAuth support is provided using the 'tokenJSONpath' option`,
                    data,
                    log: preprocessingLog$1,
                });
                // Continue because we do not want to create an OAuth viewer
                continue;
            default:
                handleWarning({
                    typeKey: 'UNSUPPORTED_HTTP_SECURITY_SCHEME',
                    message: `Unsupported HTTP authentication protocol` + `type '${protocol.type}' in OAS '${oas.info.title}'`,
                    data,
                    log: preprocessingLog$1,
                });
        }
        // Add protocol data to the output
        result[key] = {
            rawName: key,
            def: protocol,
            parameters,
            schema,
            oas,
        };
    }
    return result;
}
/**
 * Method to either create a new or reuse an existing, centrally stored data
 * definition. Data definitions are objects that hold a schema (= JSON schema),
 * an otName (= String to use as the name for object types), and an iotName
 * (= String to use as the name for input object types). Eventually, data
 * definitions also hold an ot (= the object type for the schema) and an iot
 * (= the input object type for the schema).
 *
 * Either names or preferredName should exist.
 */
function createDataDef(names, schema, isInputObjectType, data, links, oas) {
    const preferredName = getPreferredName(names);
    // Basic validation test
    if (typeof schema !== 'object') {
        handleWarning({
            typeKey: 'MISSING_SCHEMA',
            message: `Could not create data definition for schema with ` +
                `preferred name '${preferredName}' and schema '${JSON.stringify(schema)}'`,
            data,
            log: preprocessingLog$1,
        });
        // TODO: Does this change make the option fillEmptyResponses obsolete?
        return {
            preferredName,
            schema: null,
            required: [],
            links: null,
            subDefinitions: null,
            graphQLTypeName: null,
            graphQLInputObjectTypeName: null,
            targetGraphQLType: 'json',
        };
    }
    else {
        if ('$ref' in schema) {
            schema = resolveRef(schema.$ref, oas);
        }
        const saneLinks = {};
        if (typeof links === 'object') {
            Object.keys(links).forEach((linkKey) => {
                saneLinks[sanitize(linkKey, !data.options.simpleNames ? CaseStyle.camelCase : CaseStyle.simple)] = links[linkKey];
            });
        }
        // Determine the index of possible existing data definition
        const index = getSchemaIndex(preferredName, schema, data.defs);
        if (index !== -1) {
            // Found existing data definition and fetch it
            const existingDataDef = data.defs[index];
            /**
             * Collapse links if possible, i.e. if the current operation has links,
             * combine them with the prexisting ones
             */
            if (typeof saneLinks !== 'undefined') {
                if (typeof existingDataDef.links !== 'undefined') {
                    // Check if there are any overlapping links
                    Object.keys(existingDataDef.links).forEach(saneLinkKey => {
                        if (typeof saneLinks[saneLinkKey] !== 'undefined' &&
                            !deepEqual(existingDataDef.links[saneLinkKey], saneLinks[saneLinkKey])) {
                            handleWarning({
                                typeKey: 'DUPLICATE_LINK_KEY',
                                message: `Multiple operations with the same response body share the same sanitized ` +
                                    `link key '${saneLinkKey}' but have different link definitions ` +
                                    `'${JSON.stringify(existingDataDef.links[saneLinkKey])}' and ` +
                                    `'${JSON.stringify(saneLinks[saneLinkKey])}'.`,
                                data,
                                log: preprocessingLog$1,
                            });
                        }
                    });
                    /**
                     * Collapse the links
                     *
                     * Avoid overwriting preexisting links
                     */
                    existingDataDef.links = { ...saneLinks, ...existingDataDef.links };
                }
                else {
                    // No preexisting links, so simply assign the links
                    existingDataDef.links = saneLinks;
                }
            }
            return existingDataDef;
        }
        else {
            // Else, define a new name, store the def, and return it
            const name = getSchemaName(names, data.usedTypeNames);
            // Store and sanitize the name
            const saneName = !data.options.simpleNames
                ? sanitize(name, CaseStyle.PascalCase)
                : capitalize(sanitize(name, CaseStyle.simple));
            const saneInputName = capitalize(saneName + 'Input');
            storeSaneName(saneName, name, data.saneMap);
            /**
             * TODO: is there a better way of copying the schema object?
             *
             * Perhaps, just copy it at the root level (operation schema)
             */
            const collapsedSchema = resolveAllOf(schema, {}, data, oas);
            const targetGraphQLType = getSchemaTargetGraphQLType(collapsedSchema, data);
            const def = {
                preferredName,
                /**
                 * Note that schema may contain $ref or schema composition (e.g. allOf)
                 *
                 * TODO: the schema is used in getSchemaIndex, which allows us to check
                 * whether a dataDef has already been created for that particular
                 * schema and name pair. The look up should resolve references but
                 * currently, it does not.
                 */
                schema,
                required: [],
                targetGraphQLType,
                subDefinitions: undefined,
                links: saneLinks,
                graphQLTypeName: saneName,
                graphQLInputObjectTypeName: saneInputName,
            };
            // Used type names and defs of union and object types are pushed during creation
            if (targetGraphQLType === 'object' || targetGraphQLType === 'list' || targetGraphQLType === 'enum') {
                data.usedTypeNames.push(saneName);
                data.usedTypeNames.push(saneInputName);
                // Add the def to the master list
                data.defs.push(def);
            }
            // We currently only support simple cases of anyOf and oneOf
            if (
            // TODO: Should also consider if the member schema contains type data
            (Array.isArray(collapsedSchema.anyOf) && Array.isArray(collapsedSchema.oneOf)) || // anyOf and oneOf used concurrently
                hasNestedAnyOfUsage(collapsedSchema, oas) ||
                hasNestedOneOfUsage(collapsedSchema, oas)) {
                handleWarning({
                    typeKey: 'COMBINE_SCHEMAS',
                    message: `Schema '${JSON.stringify(schema)}' contains either both ` +
                        `'anyOf' and 'oneOf' or nested 'anyOf' and 'oneOf' which ` +
                        `is currently not supported.`,
                    mitigationAddendum: `Use arbitrary JSON type instead.`,
                    data,
                    log: preprocessingLog$1,
                });
                def.targetGraphQLType = 'json';
                return def;
            }
            // oneOf will ideally be turned into a union type
            if (Array.isArray(collapsedSchema.oneOf)) {
                const oneOfDataDef = createDataDefFromOneOf({
                    saneName,
                    saneInputName,
                    collapsedSchema,
                    isInputObjectType,
                    def,
                    data,
                    oas,
                });
                if (typeof oneOfDataDef === 'object') {
                    return oneOfDataDef;
                }
            }
            /**
             * anyOf will ideally be turned into an object type
             *
             * Fields common to all member schemas will be made non-null
             */
            if (Array.isArray(collapsedSchema.anyOf)) {
                const anyOfDataDef = createDataDefFromAnyOf({
                    saneName,
                    saneInputName,
                    collapsedSchema,
                    isInputObjectType,
                    def,
                    data,
                    oas,
                });
                if (typeof anyOfDataDef === 'object') {
                    return anyOfDataDef;
                }
            }
            if (targetGraphQLType) {
                switch (targetGraphQLType) {
                    case 'list':
                        if (typeof collapsedSchema.items === 'object') {
                            // Break schema down into component parts
                            // I.e. if it is an list type, create a reference to the list item type
                            // Or if it is an object type, create references to all of the field types
                            const itemsSchema = collapsedSchema.items;
                            let itemsName = `${name}ListItem`;
                            if ('$ref' in itemsSchema) {
                                itemsName = collapsedSchema.items.$ref.split('/').pop();
                            }
                            const subDefinition = createDataDef(
                            // Is this the correct classification for this name? It does not matter in the long run.
                            { fromRef: itemsName }, itemsSchema, isInputObjectType, data, undefined, oas);
                            // Add list item reference
                            def.subDefinitions = subDefinition;
                        }
                        break;
                    case 'object':
                        def.subDefinitions = {};
                        if (typeof collapsedSchema.properties === 'object' && Object.keys(collapsedSchema.properties).length > 0) {
                            addObjectPropertiesToDataDef(def, collapsedSchema, def.required, isInputObjectType, data, oas);
                        }
                        else {
                            handleWarning({
                                typeKey: 'OBJECT_MISSING_PROPERTIES',
                                message: `Schema ${JSON.stringify(schema)} does not have ` + `any properties`,
                                data,
                                log: preprocessingLog$1,
                            });
                            def.targetGraphQLType = 'json';
                        }
                        break;
                }
            }
            else {
                // No target GraphQL type
                handleWarning({
                    typeKey: 'UNKNOWN_TARGET_TYPE',
                    message: `No GraphQL target type could be identified for schema '${JSON.stringify(schema)}'.`,
                    data,
                    log: preprocessingLog$1,
                });
                def.targetGraphQLType = 'json';
            }
            return def;
        }
    }
}
/**
 * Returns the index of the data definition object in the given list that
 * contains the same schema and preferred name as the given one. Returns -1 if
 * that schema could not be found.
 */
function getSchemaIndex(preferredName, schema, dataDefs) {
    /**
     * TODO: instead of iterating through the whole list every time, create a
     * hashing function and store all of the DataDefinitions in a hashmap.
     */
    for (let index = 0; index < dataDefs.length; index++) {
        const def = dataDefs[index];
        /**
         * TODO: deepEquals is not sufficient. We also need to resolve references.
         * However, deepEquals should work for vast majority of cases.
         */
        if (preferredName === def.preferredName && deepEqual(schema, def.schema)) {
            return index;
        }
    }
    // The schema could not be found in the master list
    return -1;
}
/**
 * Determines the preferred name to use for schema regardless of name collisions.
 *
 * In other words, determines the ideal name for a schema.
 *
 * Similar to getSchemaName() except it does not check if the name has already
 * been taken.
 */
function getPreferredName(names) {
    if (typeof names.preferred === 'string') {
        return sanitize(names.preferred, CaseStyle.PascalCase); // CASE: preferred name already known
    }
    else if (typeof names.fromRef === 'string') {
        return sanitize(names.fromRef, CaseStyle.PascalCase); // CASE: name from reference
    }
    else if (typeof names.fromSchema === 'string') {
        return sanitize(names.fromSchema, CaseStyle.PascalCase); // CASE: name from schema (i.e., "title" property in schema)
    }
    else if (typeof names.fromPath === 'string') {
        return sanitize(names.fromPath, CaseStyle.PascalCase); // CASE: name from path
    }
    else {
        return 'PlaceholderName'; // CASE: placeholder name
    }
}
/**
 * Determines name to use for schema from previously determined schemaNames and
 * considering not reusing existing names.
 */
function getSchemaName(names, usedNames) {
    if (Object.keys(names).length === 1 && typeof names.preferred === 'string') {
        throw new Error(`Cannot create data definition without name(s), excluding the preferred name.`);
    }
    let schemaName;
    // CASE: name from reference
    if (typeof names.fromRef === 'string') {
        const saneName = sanitize(names.fromRef, CaseStyle.PascalCase);
        if (!usedNames.includes(saneName)) {
            schemaName = names.fromRef;
        }
    }
    // CASE: name from schema (i.e., "title" property in schema)
    if (!schemaName && typeof names.fromSchema === 'string') {
        const saneName = sanitize(names.fromSchema, CaseStyle.PascalCase);
        if (!usedNames.includes(saneName)) {
            schemaName = names.fromSchema;
        }
    }
    // CASE: name from path
    if (!schemaName && typeof names.fromPath === 'string') {
        const saneName = sanitize(names.fromPath, CaseStyle.PascalCase);
        if (!usedNames.includes(saneName)) {
            schemaName = names.fromPath;
        }
    }
    // CASE: all names are already used - create approximate name
    if (!schemaName) {
        schemaName = sanitize(typeof names.fromRef === 'string'
            ? names.fromRef
            : typeof names.fromSchema === 'string'
                ? names.fromSchema
                : typeof names.fromPath === 'string'
                    ? names.fromPath
                    : 'PlaceholderName', CaseStyle.PascalCase);
    }
    if (usedNames.includes(schemaName)) {
        let appendix = 2;
        /**
         * GraphQL Objects cannot share the name so if the name already exists in
         * the master list append an incremental number until the name does not
         * exist anymore.
         */
        while (usedNames.includes(`${schemaName}${appendix}`)) {
            appendix++;
        }
        schemaName = `${schemaName}${appendix}`;
    }
    return schemaName;
}
/**
 * Add the properties to the data definition
 */
function addObjectPropertiesToDataDef(def, schema, required, isInputObjectType, data, oas) {
    /**
     * Resolve all required properties
     *
     * TODO: required may contain duplicates, which is not necessarily a problem
     */
    if (Array.isArray(schema.required)) {
        schema.required.forEach(requiredProperty => {
            required.push(requiredProperty);
        });
    }
    for (const propertyKey in schema.properties) {
        let propSchemaName = propertyKey;
        let propSchema = schema.properties[propertyKey];
        if ('$ref' in propSchema) {
            propSchemaName = propSchema.$ref.split('/').pop();
            propSchema = resolveRef(propSchema.$ref, oas);
        }
        if (!(propertyKey in def.subDefinitions)) {
            const subDefinition = createDataDef({
                fromRef: propSchemaName,
                fromSchema: propSchema.title,
            }, propSchema, isInputObjectType, data, undefined, oas);
            // Add field type references
            def.subDefinitions[propertyKey] = subDefinition;
        }
        else {
            handleWarning({
                typeKey: 'DUPLICATE_FIELD_NAME',
                message: `By way of resolving 'allOf', multiple schemas contain ` +
                    `properties with the same name, preventing consolidation. Cannot ` +
                    `add property '${propertyKey}' from schema '${JSON.stringify(schema)}' ` +
                    `to dataDefinition '${JSON.stringify(def)}'`,
                data,
                log: preprocessingLog$1,
            });
        }
    }
}
/**
 * Recursively traverse a schema and resolve allOf by appending the data to the
 * parent schema
 */
function resolveAllOf(schema, references, data, oas) {
    // Dereference schema
    if ('$ref' in schema) {
        const referenceLocation = schema.$ref;
        schema = resolveRef(schema.$ref, oas);
        if (referenceLocation in references) {
            return references[referenceLocation];
        }
        else {
            // Store references in case of circular allOf
            references[referenceLocation] = schema;
        }
    }
    const collapsedSchema = JSON.parse(JSON.stringify(schema));
    // Resolve allOf
    if (Array.isArray(collapsedSchema.allOf)) {
        collapsedSchema.allOf.forEach(memberSchema => {
            // Collapse type if applicable
            const resolvedSchema = resolveAllOf(memberSchema, references, data, oas);
            if (resolvedSchema.type) {
                if (!collapsedSchema.type) {
                    collapsedSchema.type = resolvedSchema.type;
                    // Add type if applicable
                }
                else if (collapsedSchema.type !== resolvedSchema.type) {
                    // Incompatible schema type
                    handleWarning({
                        typeKey: 'UNRESOLVABLE_SCHEMA',
                        message: `Resolving 'allOf' field in schema '${collapsedSchema}' ` +
                            `results in incompatible schema type from partial schema '${resolvedSchema}'.`,
                        data,
                        log: preprocessingLog$1,
                    });
                }
            }
            // Collapse properties if applicable
            if ('properties' in resolvedSchema) {
                if (!('properties' in collapsedSchema)) {
                    collapsedSchema.properties = {};
                }
                Object.entries(resolvedSchema.properties).forEach(([propertyName, property]) => {
                    if (propertyName in collapsedSchema) {
                        // Conflicting property
                        handleWarning({
                            typeKey: 'UNRESOLVABLE_SCHEMA',
                            message: `Resolving 'allOf' field in schema '${collapsedSchema}' ` +
                                `results in incompatible property field from partial schema '${resolvedSchema}'.`,
                            data,
                            log: preprocessingLog$1,
                        });
                    }
                    else {
                        collapsedSchema.properties[propertyName] = property;
                    }
                });
            }
            // Collapse oneOf if applicable
            if ('oneOf' in resolvedSchema) {
                if (!('oneOf' in collapsedSchema)) {
                    collapsedSchema.oneOf = [];
                }
                resolvedSchema.oneOf.forEach(oneOfProperty => {
                    collapsedSchema.oneOf.push(oneOfProperty);
                });
            }
            // Collapse anyOf if applicable
            if ('anyOf' in resolvedSchema) {
                if (!('anyOf' in collapsedSchema)) {
                    collapsedSchema.anyOf = [];
                }
                resolvedSchema.anyOf.forEach(anyOfProperty => {
                    collapsedSchema.anyOf.push(anyOfProperty);
                });
            }
            // Collapse required if applicable
            if ('required' in resolvedSchema) {
                if (!('required' in collapsedSchema)) {
                    collapsedSchema.required = [];
                }
                resolvedSchema.required.forEach(requiredProperty => {
                    if (!collapsedSchema.required.includes(requiredProperty)) {
                        collapsedSchema.required.push(requiredProperty);
                    }
                });
            }
        });
    }
    return collapsedSchema;
}
/**
 * In the context of schemas that use keywords that combine member schemas,
 * collect data on certain aspects so it is all in one place for processing.
 */
function getMemberSchemaData(schemas, data, oas) {
    const result = {
        allTargetGraphQLTypes: [],
        allProperties: [],
        allRequired: [],
    };
    schemas.forEach(schema => {
        // Dereference schemas
        if ('$ref' in schema) {
            schema = resolveRef(schema.$ref, oas);
        }
        // Consolidate target GraphQL type
        const memberTargetGraphQLType = getSchemaTargetGraphQLType(schema, data);
        if (memberTargetGraphQLType) {
            result.allTargetGraphQLTypes.push(memberTargetGraphQLType);
        }
        // Consolidate properties
        if (schema.properties) {
            result.allProperties.push(schema.properties);
        }
        // Consolidate required
        if (schema.required) {
            result.allRequired = result.allRequired.concat(schema.required);
        }
    });
    return result;
}
/**
 * Check to see if there are cases of nested oneOf fields in the member schemas
 *
 * We currently cannot handle complex cases of oneOf and anyOf
 */
function hasNestedOneOfUsage(collapsedSchema, oas) {
    // TODO: Should also consider if the member schema contains type data
    return (Array.isArray(collapsedSchema.oneOf) &&
        collapsedSchema.oneOf.some(memberSchema => {
            // anyOf and oneOf are nested
            if ('$ref' in memberSchema) {
                memberSchema = resolveRef(memberSchema.$ref, oas);
            }
            return (Array.isArray(memberSchema.anyOf) || Array.isArray(memberSchema.oneOf) // Nested oneOf would result in nested unions which are not allowed by GraphQL
            );
        }));
}
/**
 * Check to see if there are cases of nested anyOf fields in the member schemas
 *
 * We currently cannot handle complex cases of oneOf and anyOf
 */
function hasNestedAnyOfUsage(collapsedSchema, oas) {
    // TODO: Should also consider if the member schema contains type data
    return (Array.isArray(collapsedSchema.anyOf) &&
        collapsedSchema.anyOf.some(memberSchema => {
            // anyOf and oneOf are nested
            if ('$ref' in memberSchema) {
                memberSchema = resolveRef(memberSchema.$ref, oas);
            }
            return Array.isArray(memberSchema.anyOf) || Array.isArray(memberSchema.oneOf);
        }));
}
/**
 * Create a data definition for anyOf is applicable
 *
 * anyOf should resolve into an object that contains the superset of all
 * properties from the member schemas
 */
function createDataDefFromAnyOf({ saneName, saneInputName, collapsedSchema, isInputObjectType, def, data, oas, }) {
    const anyOfData = getMemberSchemaData(collapsedSchema.anyOf, data, oas);
    if (anyOfData.allTargetGraphQLTypes.some(memberTargetGraphQLType => {
        return memberTargetGraphQLType === 'object';
    })) {
        // Every member type should be an object
        if (anyOfData.allTargetGraphQLTypes.every(memberTargetGraphQLType => {
            return memberTargetGraphQLType === 'object';
        }) &&
            anyOfData.allProperties.length > 0 // Redundant check
        ) {
            // Ensure that parent schema is compatiable with oneOf
            if (def.targetGraphQLType === null || def.targetGraphQLType === 'object') {
                const allProperties = {};
                const incompatibleProperties = new Set();
                /**
                 * TODO: Check for consistent properties across all member schemas and
                 * make them into non-nullable properties by manipulating the
                 * required field
                 */
                if (typeof collapsedSchema.properties === 'object') {
                    Object.keys(collapsedSchema.properties).forEach(propertyName => {
                        allProperties[propertyName] = [collapsedSchema.properties[propertyName]];
                    });
                }
                // Check if any member schema has conflicting properties
                anyOfData.allProperties.forEach(properties => {
                    Object.keys(properties).forEach((propertyName) => {
                        if (!incompatibleProperties.has(propertyName) && // Has not been already identified as a problematic property
                            typeof allProperties[propertyName] === 'object' &&
                            allProperties[propertyName].some(property => {
                                // Property does not match a recorded one
                                return !deepEqual(property, properties[propertyName]);
                            })) {
                            incompatibleProperties.add(propertyName);
                        }
                        // Add property in the store
                        if (!(propertyName in allProperties)) {
                            allProperties[propertyName] = [];
                        }
                        allProperties[propertyName].push(properties[propertyName]);
                    });
                });
                def.subDefinitions = {};
                if (typeof collapsedSchema.properties === 'object' && Object.keys(collapsedSchema.properties).length > 0) {
                    addObjectPropertiesToDataDef(def, collapsedSchema, def.required, isInputObjectType, data, oas);
                }
                anyOfData.allProperties.forEach(properties => {
                    Object.keys(properties).forEach((propertyName) => {
                        if (!incompatibleProperties.has(propertyName)) {
                            // Dereferenced by processing anyOfData
                            const propertySchema = properties[propertyName];
                            const subDefinition = createDataDef({
                                fromRef: propertyName,
                                fromSchema: propertySchema.title,
                            }, propertySchema, isInputObjectType, data, undefined, oas);
                            /**
                             * Add field type references
                             * There should not be any collisions
                             */
                            def.subDefinitions[propertyName] = subDefinition;
                        }
                    });
                });
                // Add in incompatible properties
                incompatibleProperties.forEach(propertyName => {
                    // TODO: add description
                    def.subDefinitions[propertyName] = {
                        targetGraphQLType: 'json',
                    };
                });
                data.usedTypeNames.push(saneName);
                data.usedTypeNames.push(saneInputName);
                data.defs.push(def);
                def.targetGraphQLType = 'object';
                return def;
            }
            else {
                // The parent schema is incompatible with the member schemas
                handleWarning({
                    typeKey: 'COMBINE_SCHEMAS',
                    message: `Schema '${JSON.stringify(def.schema)}' contains 'anyOf' and ` +
                        `some member schemas are object types so create a GraphQL ` +
                        `object type but the parent schema is a non-object type ` +
                        `so they are not compatible.`,
                    mitigationAddendum: `Use arbitrary JSON type instead.`,
                    data,
                    log: preprocessingLog$1,
                });
                def.targetGraphQLType = 'json';
                return def;
            }
        }
        else {
            // The member schemas are not all object types
            handleWarning({
                typeKey: 'COMBINE_SCHEMAS',
                message: `Schema '${def.schema}' contains 'anyOf' and ` +
                    `some member schemas are object types so create a GraphQL ` +
                    `object type but some member schemas are non-object types ` +
                    `so they are not compatible.`,
                data,
                log: preprocessingLog$1,
            });
            def.targetGraphQLType = 'json';
            return def;
        }
    }
}
function createDataDefFromOneOf({ saneName, saneInputName, collapsedSchema, isInputObjectType, def, data, oas, }) {
    const oneOfData = getMemberSchemaData(collapsedSchema.oneOf, data, oas);
    if (oneOfData.allTargetGraphQLTypes.some(memberTargetGraphQLType => {
        return memberTargetGraphQLType === 'object';
    })) {
        // unions must be created from object types
        if (oneOfData.allTargetGraphQLTypes.every(memberTargetGraphQLType => {
            return memberTargetGraphQLType === 'object';
        }) &&
            oneOfData.allProperties.length > 0 // Redundant check
        ) {
            // Ensure that parent schema is compatiable with oneOf
            if (def.targetGraphQLType === null || def.targetGraphQLType === 'object') {
                def.subDefinitions = [];
                collapsedSchema.oneOf.forEach(memberSchema => {
                    // Dereference member schema
                    let fromRef;
                    if ('$ref' in memberSchema) {
                        fromRef = memberSchema.$ref.split('/').pop();
                        memberSchema = resolveRef(memberSchema.$ref, oas);
                    }
                    // Member types of GraphQL unions must be object types
                    if (getSchemaTargetGraphQLType(memberSchema, data) === 'object') {
                        const subDefinition = createDataDef({
                            fromRef,
                            fromSchema: memberSchema.title,
                            fromPath: `${saneName}Member`,
                        }, memberSchema, isInputObjectType, data, undefined, oas);
                        def.subDefinitions.push(subDefinition);
                    }
                    else {
                        handleWarning({
                            typeKey: 'COMBINE_SCHEMAS',
                            message: `Schema '${JSON.stringify(def.schema)}' contains 'oneOf' so ` +
                                `create a GraphQL union type but member schema '${JSON.stringify(memberSchema)}' ` +
                                `is not an object type and union member types must be ` +
                                `object base types.`,
                            data,
                            log: preprocessingLog$1,
                        });
                    }
                });
                // Not all member schemas may have been turned into GraphQL member types
                if (def.subDefinitions.length > 0 &&
                    def.subDefinitions.every(subDefinition => {
                        return subDefinition.targetGraphQLType === 'object';
                    })) {
                    // Ensure all member schemas have been verified as object types
                    data.usedTypeNames.push(saneName);
                    data.usedTypeNames.push(saneInputName);
                    data.defs.push(def);
                    def.targetGraphQLType = 'union';
                    return def;
                }
                else {
                    handleWarning({
                        typeKey: 'COMBINE_SCHEMAS',
                        message: `Schema '${JSON.stringify(def.schema)}' contains 'oneOf' so ` +
                            `create a GraphQL union type but all member schemas are not` +
                            `object types and union member types must be object types.`,
                        mitigationAddendum: `Use arbitrary JSON type instead.`,
                        data,
                        log: preprocessingLog$1,
                    });
                    // Default arbitrary JSON type
                    def.targetGraphQLType = 'json';
                    return def;
                }
            }
            else {
                // The parent schema is incompatible with the member schemas
                handleWarning({
                    typeKey: 'COMBINE_SCHEMAS',
                    message: `Schema '${JSON.stringify(def.schema)}' contains 'oneOf' so create ` +
                        `a GraphQL union type but the parent schema is a non-object ` +
                        `type and member types must be object types.`,
                    mitigationAddendum: `Use arbitrary JSON type instead.`,
                    data,
                    log: preprocessingLog$1,
                });
                def.targetGraphQLType = 'json';
                return def;
            }
        }
        else {
            // The member schemas are not all object types
            handleWarning({
                typeKey: 'COMBINE_SCHEMAS',
                message: `Schema '${JSON.stringify(def.schema)}' contains 'oneOf' so create ` +
                    `a GraphQL union type but some member schemas are non-object ` +
                    `types and union member types must be object types.`,
                mitigationAddendum: `Use arbitrary JSON type instead.`,
                data,
                log: preprocessingLog$1,
            });
            def.targetGraphQLType = 'json';
            return def;
        }
    }
}

/* eslint-disable @typescript-eslint/ban-ts-comment */
const translationLog$2 = debug('translation');
/**
 * Creates and returns a GraphQL type for the given JSON schema.
 */
function getGraphQLType({ def, operation, data, iteration = 0, isInputObjectType = false, }) {
    const name = isInputObjectType ? def.graphQLInputObjectTypeName : def.graphQLTypeName;
    // Avoid excessive iterations
    if (iteration === 50) {
        throw new Error(`GraphQL type ${name} has excessive nesting of other types`);
    }
    switch (def.targetGraphQLType) {
        // CASE: object - create object type
        case 'object':
            return createOrReuseOt({
                def,
                operation,
                data,
                iteration,
                isInputObjectType,
            });
        // CASE: union - create union type
        case 'union':
            return createOrReuseUnion({
                def,
                operation,
                data,
                iteration,
            });
        // CASE: list - create list type
        case 'list':
            return createOrReuseList({
                def,
                operation,
                data,
                iteration,
                isInputObjectType,
            });
        // CASE: enum - create enum type
        case 'enum':
            return createOrReuseEnum({
                def,
                data,
            });
        // CASE: scalar - return scalar type
        default:
            return getScalarType({
                def,
                data,
            });
    }
}
/**
 * Creates an (input) object type or return an existing one, and stores it
 * in data
 *
 * A returned GraphQLObjectType has the following internal structure:
 *
 *   new GraphQLObjectType({
 *     name        // Optional name of the type
 *     description // Optional description of type
 *     fields      // REQUIRED returning fields
 *       type      // REQUIRED definition of the field type
 *       args      // Optional definition of types
 *       resolve   // Optional function defining how to obtain this type
 *   })
 */
function createOrReuseOt({ def, operation, data, iteration, isInputObjectType, }) {
    // Try to reuse a preexisting (input) object type
    // CASE: query - reuse object type
    if (!isInputObjectType) {
        if (def.graphQLType && typeof def.graphQLType !== 'undefined') {
            translationLog$2(`Reuse object type '${def.graphQLTypeName}'` +
                (typeof operation === 'object' ? ` (for operation '${operation.operationString}')` : ''));
            return def.graphQLType;
        }
        // CASE: mutation - reuse input object type
    }
    else {
        if (def.graphQLInputObjectType && typeof def.graphQLInputObjectType !== 'undefined') {
            translationLog$2(`Reuse input object type '${def.graphQLInputObjectTypeName}'` +
                (typeof operation === 'object' ? ` (for operation '${operation.operationString}')` : ''));
            return def.graphQLInputObjectType;
        }
    }
    // Cannot reuse preexisting (input) object type, therefore create one
    const schema = def.schema;
    const description = schema.description;
    // CASE: query - create object type
    if (!isInputObjectType) {
        translationLog$2(`Create object type '${def.graphQLTypeName}'` +
            (typeof operation === 'object' ? ` (for operation '${operation.operationString}')` : ''));
        def.graphQLType = new GraphQLObjectType({
            name: def.graphQLTypeName,
            description,
            fields: () => {
                return createFields({
                    def,
                    links: def.links,
                    operation,
                    data,
                    iteration,
                    isInputObjectType: false,
                });
            },
        });
        return def.graphQLType;
        // CASE: mutation - create input object type
    }
    else {
        translationLog$2(`Create input object type '${def.graphQLInputObjectTypeName}'` +
            (typeof operation === 'object' ? ` (for operation '${operation.operationString}')` : ''));
        def.graphQLInputObjectType = new GraphQLInputObjectType({
            name: def.graphQLInputObjectTypeName,
            description,
            // @ts-ignore
            fields: () => {
                return createFields({
                    def,
                    links: {},
                    operation,
                    data,
                    iteration,
                    isInputObjectType: true,
                });
            },
        });
        return def.graphQLInputObjectType;
    }
}
/**
 * Creates a union type or return an existing one, and stores it in data
 */
function createOrReuseUnion({ def, operation, data, iteration }) {
    // Try to reuse existing union type
    if (typeof def.graphQLType !== 'undefined') {
        translationLog$2(`Reuse union type '${def.graphQLTypeName}'` +
            (typeof operation === 'object' ? ` (for operation '${operation.operationString}')` : ''));
        return def.graphQLType;
    }
    else {
        translationLog$2(`Create union type '${def.graphQLTypeName}'` +
            (typeof operation === 'object' ? ` (for operation '${operation.operationString}')` : ''));
        const schema = def.schema;
        const description = typeof schema.description !== 'undefined' ? schema.description : 'No description available.';
        const memberTypeDefinitions = def.subDefinitions;
        const types = Object.values(memberTypeDefinitions).map(memberTypeDefinition => {
            return getGraphQLType({
                def: memberTypeDefinition,
                operation,
                data,
                iteration: iteration + 1,
                isInputObjectType: false,
            });
        });
        /**
         * Check for ambiguous member types
         *
         * i.e. member types that can be confused with each other.
         */
        checkAmbiguousMemberTypes(def, types, data);
        def.graphQLType = new GraphQLUnionType({
            name: def.graphQLTypeName,
            description,
            types,
            resolveType: source => {
                const properties = Object.keys(source);
                // Remove custom _openAPIToGraphQL property used to pass data
                const otgIndex = properties.indexOf('_openAPIToGraphQL');
                if (otgIndex !== -1) {
                    properties.splice(otgIndex, 1);
                }
                /**
                 * Find appropriate member type
                 *
                 * TODO: currently, the check is performed by only checking the property
                 * names. In the future, we should also check the types of those
                 * properties.
                 *
                 * TODO: there is a chance a that an intended member type cannot be
                 * identified if, for whatever reason, the return data is a superset
                 * of the fields specified in the OAS
                 */
                return types.find(type => {
                    const typeFields = Object.keys(type.getFields());
                    if (properties.length <= typeFields.length) {
                        for (let i = 0; i < properties.length; i++) {
                            if (!typeFields.includes(properties[i])) {
                                return false;
                            }
                        }
                        return true;
                    }
                    return false;
                });
            },
        });
        return def.graphQLType;
    }
}
/**
 * Check for ambiguous member types
 *
 * i.e. member types that can be confused with each other.
 */
function checkAmbiguousMemberTypes(def, types, data) {
    types.sort((a, b) => {
        const aFieldLength = Object.keys(a.getFields()).length;
        const bFieldLength = Object.keys(b.getFields()).length;
        if (aFieldLength < bFieldLength) {
            return -1;
        }
        else if (aFieldLength < bFieldLength) {
            return 1;
        }
        else {
            return 0;
        }
    });
    for (let i = 0; i < types.length - 1; i++) {
        const currentType = types[i];
        for (let j = i + 1; j < types.length; j++) {
            const otherType = types[j];
            // TODO: Check the value, not just the field name
            if (Object.keys(currentType.getFields()).every(field => {
                return Object.keys(otherType.getFields()).includes(field);
            })) {
                handleWarning({
                    typeKey: 'AMBIGUOUS_UNION_MEMBERS',
                    message: `Union created from schema '${JSON.stringify(def)}' contains ` +
                        `member types such as '${currentType}' and '${otherType}' ` +
                        `which are ambiguous. Ambiguous member types can cause ` +
                        `problems when trying to resolve types.`,
                    data,
                    log: translationLog$2,
                });
                return;
            }
        }
    }
}
/**
 * Creates a list type or returns an existing one, and stores it in data
 */
function createOrReuseList({ def, operation, iteration, isInputObjectType, data, }) {
    const name = isInputObjectType ? def.graphQLInputObjectTypeName : def.graphQLTypeName;
    // Try to reuse existing Object Type
    if (!isInputObjectType && def.graphQLType && typeof def.graphQLType !== 'undefined') {
        translationLog$2(`Reuse GraphQLList '${def.graphQLTypeName}'`);
        return def.graphQLType;
    }
    else if (isInputObjectType && def.graphQLInputObjectType && typeof def.graphQLInputObjectType !== 'undefined') {
        translationLog$2(`Reuse GraphQLList '${def.graphQLInputObjectTypeName}'`);
        return def.graphQLInputObjectType;
    }
    // Create new List Object Type
    translationLog$2(`Create GraphQLList '${def.graphQLTypeName}'`);
    // Get definition of the list item, which should be in the sub definitions
    const itemDef = def.subDefinitions;
    // Equivalent to schema.items
    const itemsSchema = itemDef.schema;
    // Equivalent to `{name}ListItem`
    const itemsName = itemDef.graphQLTypeName;
    const itemsType = getGraphQLType({
        def: itemDef,
        data,
        operation,
        iteration: iteration + 1,
        isInputObjectType,
    });
    if (itemsType !== null) {
        const listObjectType = new GraphQLList(itemsType);
        // Store newly created list type
        if (!isInputObjectType) {
            def.graphQLType = listObjectType;
        }
        else {
            def.graphQLInputObjectType = listObjectType;
        }
        return listObjectType;
    }
    else {
        throw new Error(`Cannot create list item object type '${itemsName}' in list
    '${name}' with schema '${JSON.stringify(itemsSchema)}'`);
    }
}
/**
 * Creates an enum type or returns an existing one, and stores it in data
 */
function createOrReuseEnum({ def }) {
    /**
     * Try to reuse existing enum type
     *
     * Enum types do not have an input variant so only check def.ot
     */
    if (def.graphQLType && typeof def.graphQLType !== 'undefined') {
        translationLog$2(`Reuse GraphQLEnumType '${def.graphQLTypeName}'`);
        return def.graphQLType;
    }
    else {
        translationLog$2(`Create GraphQLEnumType '${def.graphQLTypeName}'`);
        const values = {};
        def.schema.enum.forEach(e => {
            // Force enum values to string and value should be in ALL_CAPS
            values[sanitize(e.toString(), CaseStyle.ALL_CAPS)] = {
                value: e,
            };
        });
        // Store newly created Enum Object Type
        def.graphQLType = new GraphQLEnumType({
            name: def.graphQLTypeName,
            values,
        });
        return def.graphQLType;
    }
}
/**
 * Returns the GraphQL scalar type matching the given JSON schema type
 */
function getScalarType({ def }) {
    switch (def.targetGraphQLType) {
        case 'id':
            def.graphQLType = GraphQLID;
            break;
        case 'string':
            def.graphQLType = GraphQLString;
            break;
        case 'integer':
            def.graphQLType = GraphQLInt;
            break;
        case 'number':
            def.graphQLType = GraphQLFloat;
            break;
        case 'float':
            def.graphQLType = GraphQLFloat;
            break;
        case 'boolean':
            def.graphQLType = GraphQLBoolean;
            break;
        case 'json':
            def.graphQLType = GraphQLJSON;
            break;
        default:
            throw new Error(`Cannot process schema type '${def.targetGraphQLType}'.`);
    }
    return def.graphQLType;
}
/**
 * Creates the fields object to be used by an (input) object type
 */
function createFields({ def, links, operation, data, iteration, isInputObjectType, }) {
    let fields = {};
    const fieldTypeDefinitions = def.subDefinitions;
    // Create fields for properties
    for (const fieldTypeKey in fieldTypeDefinitions) {
        const fieldTypeDefinition = fieldTypeDefinitions[fieldTypeKey];
        const fieldSchema = fieldTypeDefinition.schema;
        // Get object type describing the property
        const objectType = getGraphQLType({
            def: fieldTypeDefinition,
            operation,
            data,
            iteration: iteration + 1,
            isInputObjectType,
        });
        const requiredProperty = typeof def.required === 'object' && def.required.includes(fieldTypeKey);
        // Finally, add the object type to the fields (using sanitized field name)
        if (objectType) {
            const saneFieldTypeKey = sanitize(fieldTypeKey, !data.options.simpleNames ? CaseStyle.camelCase : CaseStyle.simple);
            const sanePropName = storeSaneName(saneFieldTypeKey, fieldTypeKey, data.saneMap);
            fields[sanePropName] = {
                type: requiredProperty ? new GraphQLNonNull(objectType) : objectType,
                description: typeof fieldSchema === 'object' ? fieldSchema.description : null,
            };
        }
        else {
            handleWarning({
                typeKey: 'CANNOT_GET_FIELD_TYPE',
                message: `Cannot obtain GraphQL type for field '${fieldTypeKey}' in ` +
                    `GraphQL type '${JSON.stringify(def.schema)}'.`,
                data,
                log: translationLog$2,
            });
        }
    }
    if (typeof links === 'object' && // Links are present
        !isInputObjectType // Only object type (input object types cannot make use of links)
    ) {
        for (const saneLinkKey in links) {
            translationLog$2(`Create link '${saneLinkKey}'...`);
            // Check if key is already in fields
            if (saneLinkKey in fields) {
                handleWarning({
                    typeKey: 'LINK_NAME_COLLISION',
                    message: `Cannot create link '${saneLinkKey}' because parent ` +
                        `object type already contains a field with the same (sanitized) name.`,
                    data,
                    log: translationLog$2,
                });
            }
            else {
                const link = links[saneLinkKey];
                // Get linked operation
                let linkedOpId;
                // TODO: href is yet another alternative to operationRef and operationId
                if (typeof link.operationId === 'string') {
                    linkedOpId = link.operationId;
                }
                else if (typeof link.operationRef === 'string') {
                    linkedOpId = linkOpRefToOpId({
                        links,
                        linkKey: saneLinkKey,
                        operation,
                        data,
                    });
                }
                /**
                 * linkedOpId may not be initialized because operationRef may lead to an
                 * operation object that does not have an operationId
                 */
                if (typeof linkedOpId === 'string' && linkedOpId in data.operations) {
                    const linkedOp = data.operations[linkedOpId];
                    // Determine parameters provided via link
                    const argsFromLink = link.parameters;
                    // Get arguments that are not provided by the linked operation
                    let dynamicParams = linkedOp.parameters;
                    if (typeof argsFromLink === 'object') {
                        dynamicParams = dynamicParams.filter(param => {
                            return typeof argsFromLink[param.name] === 'undefined';
                        });
                    }
                    // Get resolve function for link
                    const linkResolver = data.options.resolverMiddleware(() => ({
                        operation: linkedOp,
                        argsFromLink: argsFromLink,
                        data,
                        baseUrl: data.options.baseUrl,
                        requestOptions: data.options.requestOptions,
                    }), getResolver);
                    // Get arguments for link
                    const args = getArgs({
                        parameters: dynamicParams,
                        operation: linkedOp,
                        data,
                    });
                    // Get response object type
                    const resObjectType = linkedOp.responseDefinition.graphQLType !== undefined
                        ? linkedOp.responseDefinition.graphQLType
                        : getGraphQLType({
                            def: linkedOp.responseDefinition,
                            operation,
                            data,
                            iteration: iteration + 1,
                            isInputObjectType: false,
                        });
                    let description = link.description;
                    if (data.options.equivalentToMessages && description) {
                        description += `\n\nEquivalent to ${linkedOp.operationString}`;
                    }
                    // Finally, add the object type to the fields (using sanitized field name)
                    // TODO: check if fields already has this field name
                    fields[saneLinkKey] = {
                        type: resObjectType,
                        resolve: linkResolver,
                        args,
                        description,
                    };
                }
                else {
                    handleWarning({
                        typeKey: 'UNRESOLVABLE_LINK',
                        message: `Cannot resolve target of link '${saneLinkKey}'`,
                        data,
                        log: translationLog$2,
                    });
                }
            }
        }
    }
    fields = sortObject(fields);
    return fields;
}
/**
 * Returns the operationId that an operationRef is associated to
 *
 * NOTE: If the operation does not natively have operationId, this function
 *  will try to produce an operationId the same way preprocessor.js does it.
 *
 *  Any changes to constructing operationIds in preprocessor.js should be
 *  reflected here.
 */
function linkOpRefToOpId({ links, linkKey, operation, data }) {
    const link = links[linkKey];
    if (typeof link.operationRef === 'string') {
        // TODO: external refs
        const operationRef = link.operationRef;
        let linkLocation;
        let linkRelativePathAndMethod;
        /**
         * Example relative path: '#/paths/~12.0~1repositories~1{username}/get'
         * Example absolute path: 'https://na2.gigantic-server.com/#/paths/~12.0~1repositories~1{username}/get'
         * Extract relative path from relative path
         */
        if (operationRef.substring(0, 8) === '#/paths/') {
            linkRelativePathAndMethod = operationRef;
            // Extract relative path from absolute path
        }
        else {
            /**
             * '#' may exist in other places in the path
             * '/#/' is more likely to point to the beginning of the path
             */
            const firstPathIndex = operationRef.indexOf('#/paths/');
            // Found a relative path candidate
            if (firstPathIndex !== -1) {
                // Check to see if there are other relative path candidates
                const lastPathIndex = operationRef.lastIndexOf('#/paths/');
                if (firstPathIndex !== lastPathIndex) {
                    handleWarning({
                        typeKey: 'AMBIGUOUS_LINK',
                        message: `The link '${linkKey}' in operation '${operation.operationString}' ` +
                            `contains an ambiguous operationRef '${operationRef}', ` +
                            `meaning it has multiple instances of the string '#/paths/'`,
                        data,
                        log: translationLog$2,
                    });
                    return;
                }
                linkLocation = operationRef.substring(0, firstPathIndex);
                linkRelativePathAndMethod = operationRef.substring(firstPathIndex);
                // Cannot find relative path candidate
            }
            else {
                handleWarning({
                    typeKey: 'UNRESOLVABLE_LINK',
                    message: `The link '${linkKey}' in operation '${operation.operationString}' ` +
                        `does not contain a valid path in operationRef '${operationRef}', ` +
                        `meaning it does not contain a string '#/paths/'`,
                    data,
                    log: translationLog$2,
                });
                return;
            }
        }
        // Infer operationId from relative path
        if (typeof linkRelativePathAndMethod === 'string') {
            let linkPath;
            let linkMethod;
            /**
             * NOTE: I wish we could extract the linkedOpId by matching the
             * linkedOpObject with an operation in data and extracting the operationId
             * there but that does not seem to be possible especiially because you
             * need to know the operationId just to access the operations so what I
             * have to do is reconstruct the operationId the same way preprocessing
             * does it
             */
            /**
             * linkPath should be the path followed by the method
             *
             * Find the slash that divides the path from the method
             */
            const pivotSlashIndex = linkRelativePathAndMethod.lastIndexOf('/');
            // Check if there are any '/' in the linkPath
            if (pivotSlashIndex !== -1) {
                // Get method
                // Check if there is a method at the end of the linkPath
                if (pivotSlashIndex !== linkRelativePathAndMethod.length - 1) {
                    // Start at +1 because we do not want the starting '/'
                    linkMethod = linkRelativePathAndMethod.substring(pivotSlashIndex + 1);
                    // Check if method is a valid method
                    if (!OAS_OPERATIONS.includes(linkMethod)) {
                        handleWarning({
                            typeKey: 'UNRESOLVABLE_LINK',
                            message: `The operationRef '${operationRef}' contains an ` + `invalid HTTP method '${linkMethod}'`,
                            data,
                            log: translationLog$2,
                        });
                        return;
                    }
                    // There is no method at the end of the path
                }
                else {
                    handleWarning({
                        typeKey: 'UNRESOLVABLE_LINK',
                        message: `The operationRef '${operationRef}' does not contain an` + `HTTP method`,
                        data,
                        log: translationLog$2,
                    });
                    return;
                }
                /**
                 * Get path
                 *
                 * Substring starts at index 8 and ends at pivotSlashIndex to exclude
                 * the '/'s at the ends of the path
                 *
                 * TODO: improve removing '/#/paths'?
                 */
                linkPath = linkRelativePathAndMethod.substring(8, pivotSlashIndex);
                /**
                 * linkPath is currently a JSON Pointer
                 *
                 * Revert the escaped '/', represented by '~1', to form intended path
                 */
                linkPath = linkPath.replace(/~1/g, '/');
                // Find the right oas
                const oas = typeof linkLocation === 'undefined' ? operation.oas : getOasFromLinkLocation({ linkLocation, link, data });
                // If the link was external, make sure that an OAS could be identified
                if (typeof oas !== 'undefined') {
                    if (typeof linkMethod === 'string' && typeof linkPath === 'string') {
                        let linkedOpId;
                        if (linkPath in oas.paths && linkMethod in oas.paths[linkPath]) {
                            const linkedOpObject = oas.paths[linkPath][linkMethod];
                            if ('operationId' in linkedOpObject) {
                                linkedOpId = linkedOpObject.operationId;
                            }
                        }
                        if (typeof linkedOpId !== 'string') {
                            linkedOpId = generateOperationId(linkMethod, linkPath);
                        }
                        if (linkedOpId in data.operations) {
                            return linkedOpId;
                        }
                        else {
                            handleWarning({
                                typeKey: 'UNRESOLVABLE_LINK',
                                message: `The link '${linkKey}' references an operation with ` +
                                    `operationId '${linkedOpId}' but no such operation exists. ` +
                                    `Note that the operationId may be autogenerated but ` +
                                    `regardless, the link could not be matched to an operation.`,
                                data,
                                log: translationLog$2,
                            });
                        }
                        // Path and method could not be found
                    }
                    else {
                        handleWarning({
                            typeKey: 'UNRESOLVABLE_LINK',
                            message: `Cannot identify path and/or method, '${linkPath} and ` +
                                `'${linkMethod}' respectively, from operationRef ` +
                                `'${operationRef}' in link '${linkKey}'`,
                            data,
                            log: translationLog$2,
                        });
                    }
                    // External link could not be resolved
                }
                else {
                    handleWarning({
                        typeKey: 'UNRESOLVABLE_LINK',
                        message: `The link '${link.operationRef}' references an external OAS ` + `but it was not provided`,
                        data,
                        log: translationLog$2,
                    });
                }
                // Cannot split relative path into path and method sections
            }
            else {
                handleWarning({
                    typeKey: 'UNRESOLVABLE_LINK',
                    message: `Cannot extract path and/or method from operationRef ` + `'${operationRef}' in link '${linkKey}'`,
                    data,
                    log: translationLog$2,
                });
            }
            // Cannot extract relative path from absolute path
        }
        else {
            handleWarning({
                typeKey: 'UNRESOLVABLE_LINK',
                message: `Cannot extract path and/or method from operationRef ` + `'${operationRef}' in link '${linkKey}'`,
                data,
                log: translationLog$2,
            });
        }
    }
}
/**
 * Creates the arguments for resolving a field
 */
function getArgs({ requestPayloadDef, parameters, operation, data }) {
    let args = {};
    // Handle params:
    for (const parameter of parameters) {
        // We need at least a name
        if (typeof parameter.name !== 'string') {
            handleWarning({
                typeKey: 'INVALID_OAS',
                message: `The operation '${operation.operationString}' contains a ` +
                    `parameter '${JSON.stringify(parameter)}' with no 'name' property`,
                data,
                log: translationLog$2,
            });
            continue;
        }
        // If this parameter is provided via options, ignore
        if (typeof data.options === 'object') {
            switch (parameter.in) {
                case 'header':
                    // Check header option
                    if (typeof data.options.headers === 'object' && parameter.name in data.options.headers) {
                        continue;
                    }
                    // Check requestOptions option
                    if (typeof data.options.requestOptions === 'object' &&
                        typeof data.options.requestOptions.headers === 'object' &&
                        parameter.name in data.options.requestOptions.headers) {
                        continue;
                    }
                    break;
                case 'query':
                    // Check header option
                    if (typeof data.options.qs === 'object' && parameter.name in data.options.qs) {
                        continue;
                    }
                    break;
            }
        }
        /**
         * Determine type of parameter
         *
         * The type of the parameter can either be contained in the "schema" field
         * or the "content" field (but not both)
         */
        let schema;
        if (typeof parameter.schema === 'object') {
            schema = parameter.schema;
        }
        else if (typeof parameter.content === 'object') {
            if (typeof parameter.content['application/json'] === 'object' &&
                typeof parameter.content['application/json'].schema === 'object') {
                schema = parameter.content['application/json'].schema;
            }
            else {
                handleWarning({
                    typeKey: 'NON_APPLICATION_JSON_SCHEMA',
                    message: `The operation '${operation.operationString}' contains a ` +
                        `parameter '${JSON.stringify(parameter)}' that has a 'content' ` +
                        `property but no schemas in application/json format. The ` +
                        `parameter will not be created`,
                    data,
                    log: translationLog$2,
                });
                continue;
            }
        }
        else {
            // Invalid OAS according to 3.0.2
            handleWarning({
                typeKey: 'INVALID_OAS',
                message: `The operation '${operation.operationString}' contains a ` +
                    `parameter '${JSON.stringify(parameter)}' with no 'schema' or ` +
                    `'content' property`,
                data,
                log: translationLog$2,
            });
            continue;
        }
        /**
         * Resolving the reference is necessary later in the code and by doing it,
         * we can avoid doing it a second time in resolveRev()
         */
        if ('$ref' in schema) {
            schema = resolveRef(schema.$ref, operation.oas);
        }
        // TODO: remove
        const paramDef = createDataDef({ fromSchema: parameter.name }, schema, true, data);
        // @ts-ignore
        const type = getGraphQLType({
            def: paramDef,
            operation,
            data,
            iteration: 0,
            isInputObjectType: true,
        });
        /**
         * Sanitize the argument name
         *
         * NOTE: when matching these parameters back to requests, we need to again
         * use the real parameter name
         */
        const saneName = sanitize(parameter.name, !data.options.simpleNames ? CaseStyle.camelCase : CaseStyle.simple);
        // Parameters are not required when a default exists:
        let hasDefault = false;
        if (typeof parameter.schema === 'object') {
            let schema = parameter.schema;
            if (typeof schema.$ref === 'string') {
                schema = resolveRef(parameter.schema.$ref, operation.oas);
            }
            if (typeof schema.default !== 'undefined') {
                hasDefault = true;
            }
        }
        const paramRequired = parameter.required && !hasDefault;
        args[saneName] = {
            type: paramRequired ? new GraphQLNonNull(type) : type,
            description: parameter.description,
        };
    }
    // Add limit argument
    if (data.options.addLimitArgument &&
        typeof operation.responseDefinition === 'object' &&
        operation.responseDefinition.schema.type === 'array' &&
        // Only add limit argument to lists of object types, not to lists of scalar types
        (operation.responseDefinition.subDefinitions.schema.type === 'object' ||
            operation.responseDefinition.subDefinitions.schema.type === 'array')) {
        // Make sure slicing arguments will not overwrite preexisting arguments
        if ('limit' in args) {
            handleWarning({
                typeKey: 'LIMIT_ARGUMENT_NAME_COLLISION',
                message: `The 'limit' argument cannot be added ` +
                    `because of a preexisting argument in ` +
                    `operation ${operation.operationString}`,
                data,
                log: translationLog$2,
            });
        }
        else {
            args.limit = {
                type: GraphQLInt,
                description: `Auto-generated argument that limits the size of ` +
                    `returned list of objects/list, selecting the first \`n\` ` +
                    `elements of the list`,
            };
        }
    }
    // Handle request payload (if present):
    if (typeof requestPayloadDef === 'object') {
        const reqObjectType = getGraphQLType({
            def: requestPayloadDef,
            data,
            operation,
            isInputObjectType: true,
        });
        // Sanitize the argument name
        const saneName = data.options.genericPayloadArgName
            ? 'requestBody'
            : uncapitalize(requestPayloadDef.graphQLInputObjectTypeName); // Already sanitized
        const reqRequired = typeof operation === 'object' && typeof operation.payloadRequired === 'boolean'
            ? operation.payloadRequired
            : false;
        args[saneName] = {
            type: reqRequired ? new GraphQLNonNull(reqObjectType) : reqObjectType,
            // TODO: addendum to the description explaining this is the request body
            description: requestPayloadDef.schema.description,
        };
    }
    args = sortObject(args);
    return args;
}
/**
 * Used in the context of links, specifically those using an external operationRef
 * If the reference is an absolute reference, determine the type of location
 *
 * For example, name reference, file path, web-hosted OAS link, etc.
 */
function getLinkLocationType() {
    // TODO: currently we only support the title as a link location
    return 'title';
}
/**
 * Used in the context of links, specifically those using an external operationRef
 * Based on the location of the OAS, retrieve said OAS
 */
function getOasFromLinkLocation({ linkLocation, link, data, }) {
    // May be an external reference
    switch (getLinkLocationType()) {
        case 'title':
            // Get the possible
            const possibleOass = data.oass.filter(oas => {
                return oas.info.title === linkLocation;
            });
            // Check if there are an ambiguous OASs
            if (possibleOass.length === 1) {
                // No ambiguity
                return possibleOass[0];
            }
            else if (possibleOass.length > 1) {
                // Some ambiguity
                handleWarning({
                    typeKey: 'AMBIGUOUS_LINK',
                    message: `The operationRef '${link.operationRef}' references an ` +
                        `OAS '${linkLocation}' but multiple OASs share the same title`,
                    data,
                    log: translationLog$2,
                });
            }
            else {
                // No OAS had the expected title
                handleWarning({
                    typeKey: 'UNRESOLVABLE_LINK',
                    message: `The operationRef '${link.operationRef}' references an ` +
                        `OAS '${linkLocation}' but no such OAS was provided`,
                    data,
                    log: translationLog$2,
                });
            }
            break;
        // // TODO
        // case 'url':
        //   break
        // // TODO
        // case 'file':
        //   break
        // TODO: should title be default?
        // In cases of names like api.io
        default:
            handleWarning({
                typeKey: 'UNRESOLVABLE_LINK',
                message: `The link location of the operationRef ` +
                    `'${link.operationRef}' is currently not supported\n` +
                    `Currently only the title of the OAS is supported`,
                data,
                log: translationLog$2,
            });
    }
}

// Copyright IBM Corp. 2018. All Rights Reserved.
/**
 * Returns empty GraphQLObjectType.
 */
function getEmptyObjectType(name) {
    return new GraphQLObjectType({
        name: name + 'Placeholder',
        description: 'Placeholder object',
        fields: {
            message: {
                type: GraphQLString,
                description: 'Placeholder field',
                resolve: () => {
                    return 'This is a placeholder field.';
                },
            },
        },
    });
}

// Copyright IBM Corp. 2018. All Rights Reserved.
const translationLog$3 = debug('translation');
/**
 * Load the field object in the appropriate root object
 *
 * i.e. inside either rootQueryFields/rootMutationFields or inside
 * rootQueryFields/rootMutationFields for further processing
 */
function createAndLoadViewer(queryFields, data, isMutation = false) {
    const results = {};
    /**
     * To ensure that viewers have unique names, we add a numerical postfix.
     *
     * This object keeps track of what the postfix should be.
     *
     * The key is the security scheme type and the value is
     * the current highest postfix used for viewers of that security scheme type.
     */
    const viewerNamePostfix = {};
    /**
     * Used to collect all fields in the given querFields object, no matter which
     * protocol. Used to populate anyAuthViewer.
     */
    const anyAuthFields = {};
    for (const protocolName in queryFields) {
        Object.assign(anyAuthFields, queryFields[protocolName]);
        /**
         * Check if the name has already been used (i.e. in the list)
         * if so, create a new name and add it to the list
         */
        const securityType = data.security[protocolName].def.type;
        let viewerType;
        /**
         * HTTP is not an authentication protocol
         * HTTP covers a number of different authentication type
         * change the typeName to match the exact authentication type (e.g. basic
         * authentication)
         */
        if (securityType === 'http') {
            const scheme = data.security[protocolName].def.scheme;
            switch (scheme) {
                case 'basic':
                    viewerType = 'basicAuth';
                    break;
                default:
                    handleWarning({
                        typeKey: 'UNSUPPORTED_HTTP_SECURITY_SCHEME',
                        message: `Currently unsupported HTTP authentication protocol ` + `type 'http' and scheme '${scheme}'`,
                        data,
                        log: translationLog$3,
                    });
                    continue;
            }
        }
        else {
            viewerType = securityType;
        }
        // Create name for the viewer
        let viewerName = !isMutation
            ? sanitize(`viewer ${viewerType}`, CaseStyle.camelCase)
            : sanitize(`mutation viewer ${viewerType}`, CaseStyle.camelCase);
        // Ensure unique viewer name
        // If name already exists, append a number at the end of the name
        if (!(viewerType in viewerNamePostfix)) {
            viewerNamePostfix[viewerType] = 1;
        }
        else {
            viewerName += ++viewerNamePostfix[viewerType];
        }
        // Add the viewer object type to the specified root query object type
        results[viewerName] = getViewerOT(viewerName, protocolName, securityType, queryFields[protocolName], data);
    }
    // Create name for the AnyAuth viewer
    const anyAuthObjectName = !isMutation ? 'viewerAnyAuth' : 'mutationViewerAnyAuth';
    // Add the AnyAuth object type to the specified root query object type
    results[anyAuthObjectName] = getViewerAnyAuthOT(anyAuthObjectName, anyAuthFields, data);
    return results;
}
/**
 * Gets the viewer Object, resolve function, and arguments
 */
const getViewerOT = (name, protocolName, securityType, queryFields, data) => {
    const scheme = data.security[protocolName];
    // Resolve function:
    const resolve = (_root, args, _ctx) => {
        const security = {};
        const saneProtocolName = sanitize(protocolName, CaseStyle.camelCase);
        security[storeSaneName(saneProtocolName, protocolName, data.saneMap)] = args;
        /**
         * Viewers are always root, so we can instantiate _openAPIToGraphQL here without
         * previously checking for its existence
         */
        return {
            _openAPIToGraphQL: {
                security,
            },
        };
    };
    // Arguments:
    /**
     * Do not sort because they are already "sorted" in preprocessing.
     * Otherwise, for basic auth, "password" will appear before "username"
     */
    const args = {};
    if (typeof scheme === 'object') {
        for (const parameterName in scheme.parameters) {
            args[parameterName] = { type: new GraphQLNonNull(GraphQLString) };
        }
    }
    let typeDescription = `A viewer for security scheme '${protocolName}'`;
    /**
     * HTTP authentication uses different schemes. It is not sufficient to name
     * only the security type
     */
    let description = securityType === 'http'
        ? `A viewer that wraps all operations authenticated via security scheme ` +
            `'${protocolName}', which is of type 'http' '${scheme.def.scheme}'`
        : `A viewer that wraps all operations authenticated via security scheme ` +
            `'${protocolName}', which is of type '${securityType}'`;
    if (data.oass.length !== 1) {
        typeDescription += ` in OAS '${scheme.oas.info.title}'`;
        description = `, in OAS '${scheme.oas.info.title}`;
    }
    return {
        type: new GraphQLObjectType({
            name: capitalize(name),
            description: typeDescription,
            fields: () => queryFields,
        }),
        resolve,
        args,
        description,
    };
};
/**
 * Create an object containing an AnyAuth viewer, its resolve function,
 * and its args.
 */
const getViewerAnyAuthOT = (name, queryFields, data) => {
    let args = {};
    for (const protocolName in data.security) {
        // Create input object types for the viewer arguments
        const def = createDataDef({ fromRef: protocolName }, data.security[protocolName].schema, true, data);
        const type = getGraphQLType({
            def,
            data,
            isInputObjectType: true,
        });
        const saneProtocolName = sanitize(protocolName, CaseStyle.camelCase);
        args[storeSaneName(saneProtocolName, protocolName, data.saneMap)] = { type };
    }
    args = sortObject(args);
    // Pass object containing security information to fields
    const resolve = (_root, args, _ctx) => {
        return {
            _openAPIToGraphQL: {
                security: args,
            },
        };
    };
    return {
        type: new GraphQLObjectType({
            name: capitalize(name),
            description: 'Warning: Not every request will work with this viewer type',
            fields: () => queryFields,
        }),
        resolve,
        args,
        description: `A viewer that wraps operations for all available ` + `authentication mechanisms`,
    };
};

// Copyright IBM Corp. 2018. All Rights Reserved.
const translationLog$4 = debug('translation');
/**
 * Creates a GraphQL interface from the given OpenAPI Specification (2 or 3).
 */
async function createGraphQLSchema(spec, options) {
    if (typeof options === 'undefined') {
        options = {};
    }
    // Setting default options
    options.strict = typeof options.strict === 'boolean' ? options.strict : false;
    // Schema options
    options.operationIdFieldNames =
        typeof options.operationIdFieldNames === 'boolean' ? options.operationIdFieldNames : false;
    options.fillEmptyResponses = typeof options.fillEmptyResponses === 'boolean' ? options.fillEmptyResponses : false;
    options.addLimitArgument = typeof options.addLimitArgument === 'boolean' ? options.addLimitArgument : false;
    options.genericPayloadArgName =
        typeof options.genericPayloadArgName === 'boolean' ? options.genericPayloadArgName : false;
    options.simpleNames = typeof options.simpleNames === 'boolean' ? options.simpleNames : false;
    options.singularNames = typeof options.singularNames === 'boolean' ? options.singularNames : false;
    // Authentication options
    options.viewer = typeof options.viewer === 'boolean' ? options.viewer : true;
    options.sendOAuthTokenInQuery =
        typeof options.sendOAuthTokenInQuery === 'boolean' ? options.sendOAuthTokenInQuery : false;
    // Logging options
    options.provideErrorExtensions =
        typeof options.provideErrorExtensions === 'boolean' ? options.provideErrorExtensions : true;
    options.equivalentToMessages =
        typeof options.equivalentToMessages === 'boolean' ? options.equivalentToMessages : true;
    options.fetch = typeof options.fetch === 'function' ? options.fetch : await Promise.resolve().then(function () { return nodePonyfill; }).then(m => m.fetch);
    options.resolverMiddleware =
        typeof options.resolverMiddleware === 'function'
            ? options.resolverMiddleware
            : (resolverFactoryParams, factory) => factory(resolverFactoryParams);
    options.report = {
        warnings: [],
        numOps: 0,
        numOpsQuery: 0,
        numOpsMutation: 0,
        numQueriesCreated: 0,
        numMutationsCreated: 0,
    };
    options.skipSchemaValidation =
        typeof options.skipSchemaValidation === 'boolean' ? options.skipSchemaValidation : false;
    let oass;
    if (Array.isArray(spec)) {
        /**
         * Convert all non-OAS 3.0.x into OAS 3.0.x
         */
        oass = await Promise.all(spec.map(ele => {
            return getValidOAS3(ele, options);
        }));
    }
    else {
        /**
         * Check if the spec is a valid OAS 3.0.x
         * If the spec is OAS 2.0, attempt to translate it into 3.0.x, then try to
         * translate the spec into a GraphQL schema
         */
        oass = [await getValidOAS3(spec, options)];
    }
    const { schema, report } = await translateOpenAPIToGraphQL(oass, options);
    return {
        schema,
        report,
    };
}
/**
 * Creates a GraphQL interface from the given OpenAPI Specification 3.0.x
 */
async function translateOpenAPIToGraphQL(oass, { strict, report, 
// Schema options
operationIdFieldNames, fillEmptyResponses, addLimitArgument, idFormats, selectQueryOrMutationField, genericPayloadArgName, simpleNames, singularNames, 
// Resolver options
headers, qs, requestOptions, baseUrl, customResolvers, fetch, resolverMiddleware, 
// Authentication options
viewer, tokenJSONpath, sendOAuthTokenInQuery, 
// Logging options
provideErrorExtensions, equivalentToMessages, }) {
    const options = {
        strict,
        report,
        // Schema options
        operationIdFieldNames,
        fillEmptyResponses,
        addLimitArgument,
        idFormats,
        selectQueryOrMutationField,
        genericPayloadArgName,
        simpleNames,
        singularNames,
        // Resolver options
        headers,
        qs,
        requestOptions,
        baseUrl,
        customResolvers,
        fetch,
        resolverMiddleware,
        // Authentication options
        viewer,
        tokenJSONpath,
        sendOAuthTokenInQuery,
        // Logging options
        provideErrorExtensions,
        equivalentToMessages,
    };
    translationLog$4(`Options: ${JSON.stringify(options)}`);
    /**
     * Extract information from the OASs and put it inside a data structure that
     * is easier for OpenAPI-to-GraphQL to use
     */
    const data = preprocessOas(oass, options);
    preliminaryChecks(options, data);
    /**
     * Create GraphQL fields for every operation and structure them based on their
     * characteristics (query vs. mutation, auth vs. non-auth).
     */
    let queryFields = {};
    let mutationFields = {};
    let authQueryFields = {};
    let authMutationFields = {};
    Object.entries(data.operations).forEach(([operationId, operation]) => {
        translationLog$4(`Process operation '${operation.operationString}'...`);
        const field = getFieldForOperation(operation, options.baseUrl, data, requestOptions);
        const saneOperationId = sanitize(operationId, CaseStyle.camelCase);
        // Check if the operation should be added as a Query or Mutation field
        if (!operation.isMutation) {
            let fieldName = !singularNames
                ? uncapitalize(operation.responseDefinition.graphQLTypeName)
                : sanitize(inferResourceNameFromPath(operation.path), CaseStyle.camelCase);
            if (operation.inViewer) {
                for (const securityRequirement of operation.securityRequirements) {
                    if (typeof authQueryFields[securityRequirement] !== 'object') {
                        authQueryFields[securityRequirement] = {};
                    }
                    // Avoid overwriting fields that return the same data:
                    if (fieldName in authQueryFields[securityRequirement] ||
                        /**
                         * If the option is set operationIdFieldNames, the fieldName is
                         * forced to be the operationId
                         */
                        operationIdFieldNames) {
                        fieldName = storeSaneName(saneOperationId, operationId, data.saneMap);
                    }
                    if (fieldName in authQueryFields[securityRequirement]) {
                        handleWarning({
                            typeKey: 'DUPLICATE_FIELD_NAME',
                            message: `Multiple operations have the same name ` +
                                `'${fieldName}' and security requirement ` +
                                `'${securityRequirement}'. GraphQL field names must be ` +
                                `unique so only one can be added to the authentication ` +
                                `viewer. Operation '${operation.operationString}' will be ignored.`,
                            data,
                            log: translationLog$4,
                        });
                    }
                    else {
                        authQueryFields[securityRequirement][fieldName] = field;
                    }
                }
            }
            else {
                // Avoid overwriting fields that return the same data:
                if (fieldName in queryFields ||
                    /**
                     * If the option is set operationIdFieldNames, the fieldName is
                     * forced to be the operationId
                     */
                    operationIdFieldNames) {
                    fieldName = storeSaneName(saneOperationId, operationId, data.saneMap);
                }
                if (fieldName in queryFields) {
                    handleWarning({
                        typeKey: 'DUPLICATE_FIELD_NAME',
                        message: `Multiple operations have the same name ` +
                            `'${fieldName}'. GraphQL field names must be ` +
                            `unique so only one can be added to the Query object. ` +
                            `Operation '${operation.operationString}' will be ignored.`,
                        data,
                        log: translationLog$4,
                    });
                }
                else {
                    queryFields[fieldName] = field;
                }
            }
        }
        else {
            let saneFieldName;
            if (!singularNames) {
                /**
                 * Use operationId to avoid problems differentiating operations with the
                 * same path but differnet methods
                 */
                saneFieldName = storeSaneName(saneOperationId, operationId, data.saneMap);
            }
            else {
                const fieldName = `${operation.method}${inferResourceNameFromPath(operation.path)}`;
                saneFieldName = storeSaneName(sanitize(fieldName, CaseStyle.camelCase), fieldName, data.saneMap);
            }
            if (operation.inViewer) {
                for (const securityRequirement of operation.securityRequirements) {
                    if (typeof authMutationFields[securityRequirement] !== 'object') {
                        authMutationFields[securityRequirement] = {};
                    }
                    if (saneFieldName in authMutationFields[securityRequirement]) {
                        handleWarning({
                            typeKey: 'DUPLICATE_FIELD_NAME',
                            message: `Multiple operations have the same name ` +
                                `'${saneFieldName}' and security requirement ` +
                                `'${securityRequirement}'. GraphQL field names must be ` +
                                `unique so only one can be added to the authentication ` +
                                `viewer. Operation '${operation.operationString}' will be ignored.`,
                            data,
                            log: translationLog$4,
                        });
                    }
                    else {
                        authMutationFields[securityRequirement][saneFieldName] = field;
                    }
                }
            }
            else {
                if (saneFieldName in mutationFields) {
                    handleWarning({
                        typeKey: 'DUPLICATE_FIELD_NAME',
                        message: `Multiple operations have the same name ` +
                            `'${saneFieldName}'. GraphQL field names must be ` +
                            `unique so only one can be added to the Mutation object. ` +
                            `Operation '${operation.operationString}' will be ignored.`,
                        data,
                        log: translationLog$4,
                    });
                }
                else {
                    mutationFields[saneFieldName] = field;
                }
            }
        }
    });
    // Sorting fields
    queryFields = sortObject(queryFields);
    mutationFields = sortObject(mutationFields);
    authQueryFields = sortObject(authQueryFields);
    Object.keys(authQueryFields).forEach((key) => {
        authQueryFields[key] = sortObject(authQueryFields[key]);
    });
    authMutationFields = sortObject(authMutationFields);
    Object.keys(authMutationFields).forEach((key) => {
        authMutationFields[key] = sortObject(authMutationFields[key]);
    });
    /**
     * Count created queries / mutations
     */
    options.report.numQueriesCreated =
        Object.keys(queryFields).length +
            Object.keys(authQueryFields).reduce((sum, key) => {
                return sum + Object.keys(authQueryFields[key]).length;
            }, 0);
    options.report.numMutationsCreated =
        Object.keys(mutationFields).length +
            Object.keys(authMutationFields).reduce((sum, key) => {
                return sum + Object.keys(authMutationFields[key]).length;
            }, 0);
    /**
     * Organize created queries / mutations into viewer objects.
     */
    if (Object.keys(authQueryFields).length > 0) {
        Object.assign(queryFields, createAndLoadViewer(authQueryFields, data, false));
    }
    if (Object.keys(authMutationFields).length > 0) {
        Object.assign(mutationFields, createAndLoadViewer(authMutationFields, data, true));
    }
    /**
     * Build up the schema
     */
    const schemaConfig = {
        query: Object.keys(queryFields).length > 0
            ? new GraphQLObjectType({
                name: 'Query',
                description: 'The start of any query',
                fields: queryFields,
            })
            : getEmptyObjectType('Query'),
        mutation: Object.keys(mutationFields).length > 0
            ? new GraphQLObjectType({
                name: 'Mutation',
                description: 'The start of any mutation',
                fields: mutationFields,
            })
            : null,
    };
    /**
     * Fill in yet undefined object types to avoid GraphQLSchema from breaking.
     *
     * The reason: once creating the schema, the 'fields' thunks will resolve and
     * if a field references an undefined object types, GraphQL will throw.
     */
    Object.entries(data.operations).forEach(([opId, operation]) => {
        if (typeof operation.responseDefinition.graphQLType === 'undefined') {
            operation.responseDefinition.graphQLType = getEmptyObjectType(operation.responseDefinition.graphQLTypeName);
        }
    });
    const schema = new GraphQLSchema(schemaConfig);
    return { schema, report: options.report };
}
/**
 * Creates the field object for the given operation.
 */
function getFieldForOperation(operation, baseUrl, data, requestOptions) {
    // Create GraphQL Type for response:
    const type = getGraphQLType({
        def: operation.responseDefinition,
        data,
        operation,
    });
    // Create resolve function:
    const payloadSchemaName = operation.payloadDefinition ? operation.payloadDefinition.graphQLInputObjectTypeName : null;
    const resolve = data.options.resolverMiddleware(() => ({
        operation,
        payloadName: payloadSchemaName,
        data,
        baseUrl,
        requestOptions,
    }), getResolver);
    // Create args:
    const args = getArgs({
        /**
         * Even though these arguments seems redundent because of the operation
         * argument, the function cannot be refactored because it is also used to
         * create arguments for links. The operation argument is really used to pass
         * data to other functions.
         */
        requestPayloadDef: operation.payloadDefinition,
        parameters: operation.parameters,
        operation,
        data,
    });
    return {
        type,
        resolve,
        args,
        description: operation.description,
    };
}
/**
 * Ensures that the options are valid
 */
function preliminaryChecks(options, data) {
    // Check if OASs have unique titles
    const titles = data.oass.map(oas => {
        return oas.info.title;
    });
    // Find duplicates among titles
    new Set(titles.filter((title, index) => {
        return titles.indexOf(title) !== index;
    })).forEach(title => {
        handleWarning({
            typeKey: 'MULTIPLE_OAS_SAME_TITLE',
            message: `Multiple OAS share the same title '${title}'`,
            data,
            log: translationLog$4,
        });
    });
    // Check customResolvers
    if (typeof options.customResolvers === 'object') {
        // Check that all OASs that are referenced in the customResolvers are provided
        Object.keys(options.customResolvers)
            .filter(title => {
            // If no OAS contains this title
            return !data.oass.some(oas => {
                return title === oas.info.title;
            });
        })
            .forEach(title => {
            handleWarning({
                typeKey: 'CUSTOM_RESOLVER_UNKNOWN_OAS',
                message: `Custom resolvers reference OAS '${title}' but no such ` + `OAS was provided`,
                data,
                log: translationLog$4,
            });
        });
        // TODO: Only run the following test on OASs that exist. See previous check.
        Object.keys(options.customResolvers).forEach(title => {
            // Get all operations from a particular OAS
            const operations = Object.values(data.operations).filter(operation => {
                return title === operation.oas.info.title;
            });
            Object.keys(options.customResolvers[title]).forEach(path => {
                Object.keys(options.customResolvers[title][path]).forEach(method => {
                    if (!operations.some(operation => {
                        return path === operation.path && method === operation.method;
                    })) {
                        handleWarning({
                            typeKey: 'CUSTOM_RESOLVER_UNKNOWN_PATH_METHOD',
                            message: `A custom resolver references an operation with ` +
                                `path '${path}' and method '${method}' but no such operation ` +
                                `exists in OAS '${title}'`,
                            data,
                            log: translationLog$4,
                        });
                    }
                });
            });
        });
    }
}

const handler = {
    async getMeshSource({ config, cache }) {
        var _a, _b, _c;
        const path = config.source;
        const spec = await readFileOrUrlWithCache(path, cache, {
            headers: config.schemaHeaders,
        });
        const fetch = (...args) => fetchache(args[0] instanceof Request ? args[0] : new Request(...args), cache);
        const headersFactory = getInterpolatedHeadersFactory(config.operationHeaders);
        const { schema } = await createGraphQLSchema(spec, {
            fetch,
            baseUrl: config.baseUrl,
            skipSchemaValidation: config.skipSchemaValidation,
            operationIdFieldNames: true,
            fillEmptyResponses: true,
            viewer: false,
            resolverMiddleware: (getResolverParams, originalFactory) => (root, args, context, info) => {
                const resolverData = { root, args, context, info };
                const resolverParams = getResolverParams();
                resolverParams.requestOptions = {
                    headers: getHeadersObject(headersFactory(resolverData)),
                };
                return originalFactory(() => resolverParams)(root, args, context, info);
            },
        });
        const { args, contextVariables } = parseInterpolationStrings(Object.values(config.operationHeaders || {}));
        const rootFields = [
            ...Object.values(((_a = schema.getQueryType()) === null || _a === void 0 ? void 0 : _a.getFields()) || {}),
            ...Object.values(((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.getFields()) || {}),
            ...Object.values(((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.getFields()) || {}),
        ];
        for (const rootField of rootFields) {
            for (const argName in args) {
                const argConfig = args[argName];
                rootField.args.push({
                    name: argName,
                    description: undefined,
                    defaultValue: undefined,
                    extensions: undefined,
                    astNode: undefined,
                    ...argConfig,
                });
            }
        }
        return {
            schema,
            contextVariables,
        };
    },
};

var nodeFetch = require('node-fetch');
var realFetch = nodeFetch.default || nodeFetch;

var fetch = function (url, options) {
  // Support schemaless URIs on the server for parity with the browser.
  // Ex: //github.com/ -> https://github.com/
  if (/^\/\//.test(url)) {
    url = 'https:' + url;
  }
  return realFetch.call(this, url, options)
};

module.exports = exports = fetch;
exports.fetch = fetch;
exports.Headers = nodeFetch.Headers;
exports.Request = nodeFetch.Request;
exports.Response = nodeFetch.Response;

// Needed for TypeScript consumers without esModuleInterop.
exports.default = fetch;

const nodePonyfill = /*#__PURE__*/Object.freeze({
    __proto__: null
});

export default handler;
//# sourceMappingURL=index.esm.js.map
