'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

const runtime = require('@graphql-mesh/runtime');
const yargs = require('yargs');
const winston = require('winston');
const tsBasePlugin = require('@graphql-codegen/typescript');
const tsResolversPlugin = require('@graphql-codegen/typescript-resolvers');
const graphql = require('graphql');
const core = require('@graphql-codegen/core');
const tsOperationsPlugin = require('@graphql-codegen/typescript-operations');
const tsGenericSdkPlugin = require('@graphql-codegen/typescript-generic-sdk');
const load = require('@graphql-tools/load');
const codeFileLoader = require('@graphql-tools/code-file-loader');
const graphqlFileLoader = require('@graphql-tools/graphql-file-loader');
const utils = require('@graphql-tools/utils');
const express = _interopDefault(require('express'));
const cluster = require('cluster');
const os = require('os');
require('json-bigint-patch');
const http = require('http');
const path = require('path');
const fsExtra = require('fs-extra');
const graphqlHTTP = _interopDefault(require('express-graphql'));
const graphqlUpload = require('graphql-upload');
const subscriptionsTransportWs = require('subscriptions-transport-ws');

const scalarsMap = {
    BigInt: 'BigInt',
    Byte: 'Buffer',
    Date: 'Date',
    DateTime: 'Date',
    GUID: 'String',
};

const unifiedContextIdentifier = 'MeshContext';
class CodegenHelpers extends tsBasePlugin.TsVisitor {
    getTypeToUse(namedType) {
        if (this.scalars[namedType.name.value]) {
            return this._getScalar(namedType.name.value);
        }
        return this._getTypeForNode(namedType);
    }
}
function buildSignatureBasedOnRootFields(codegenHelpers, type) {
    if (!type) {
        return [];
    }
    const fields = type.getFields();
    return Object.keys(fields).map(fieldName => {
        const field = fields[fieldName];
        const argsExists = field.args && field.args.length > 0;
        const argsName = argsExists ? `${type.name}${codegenHelpers.convertName(field.name)}Args` : '{}';
        const parentTypeNode = {
            kind: graphql.Kind.NAMED_TYPE,
            name: {
                kind: graphql.Kind.NAME,
                value: type.name,
            },
        };
        return `  ${field.name}: (args${argsExists ? '' : '?'}: ${argsName}, projectionOptions?: ProjectionOptions) => Promise<${codegenHelpers.getTypeToUse(parentTypeNode)}['${fieldName}']>`;
    });
}
function generateTypesForApi(options) {
    const codegenHelpers = new CodegenHelpers(options.schema, {}, {});
    const sdkIdentifier = `${options.name}Sdk`;
    const contextIdentifier = `${options.name}Context`;
    const operations = [
        ...buildSignatureBasedOnRootFields(codegenHelpers, options.schema.getQueryType()),
        ...buildSignatureBasedOnRootFields(codegenHelpers, options.schema.getMutationType()),
        ...buildSignatureBasedOnRootFields(codegenHelpers, options.schema.getSubscriptionType()),
    ];
    const sdk = {
        identifier: sdkIdentifier,
        codeAst: `export type ${sdkIdentifier} = {
${operations.join(',\n')}
};`,
    };
    const context = {
        identifier: contextIdentifier,
        codeAst: `export type ${contextIdentifier} = { 
      ${options.name}: { api: ${sdkIdentifier} }, 
    };`,
    };
    return {
        sdk,
        context,
    };
}
function generateTsTypes(unifiedSchema, rawSources, mergerType = 'stitching') {
    return core.codegen({
        filename: 'types.ts',
        documents: [],
        config: {
            scalars: scalarsMap,
            skipTypename: true,
        },
        schemaAst: unifiedSchema,
        schema: undefined,
        pluginMap: {
            typescript: tsBasePlugin,
            resolvers: tsResolversPlugin,
            contextSdk: {
                plugin: async () => {
                    const commonTypes = [
                        `import { MeshContext as OriginalMeshContext, ProjectionOptions } from '@graphql-mesh/runtime';`,
                    ];
                    const sdkItems = [];
                    const contextItems = [];
                    const results = await Promise.all(rawSources.map(source => {
                        const item = generateTypesForApi({
                            schema: unifiedSchema.extensions.sourceMap.get(source),
                            name: source.name,
                        });
                        if (item) {
                            if (item.sdk) {
                                sdkItems.push(item.sdk.codeAst);
                            }
                            if (item.context) {
                                contextItems.push(item.context.codeAst);
                            }
                        }
                        return item;
                    }));
                    const contextType = `export type ${unifiedContextIdentifier} = ${results
                        .map(r => { var _a; return (_a = r === null || r === void 0 ? void 0 : r.context) === null || _a === void 0 ? void 0 : _a.identifier; })
                        .filter(Boolean)
                        .join(' & ')} & OriginalMeshContext;`;
                    return {
                        content: [...commonTypes, ...sdkItems, ...contextItems, contextType].join('\n\n'),
                    };
                },
            },
        },
        plugins: [
            {
                typescript: {
                    namingConvention: {
                        enumValues: 'keep',
                    },
                },
            },
            {
                resolvers: {
                    useIndexSignature: true,
                    noSchemaStitching: mergerType !== 'stitching',
                    contextType: unifiedContextIdentifier,
                    federation: mergerType === 'federation',
                },
            },
            {
                contextSdk: {},
            },
        ],
    });
}

async function generateSdk(schema, { operations: operationsPaths = [], depth: depthLimit = 1, }) {
    let sources = [];
    if (operationsPaths.length) {
        sources = await load.loadDocuments(operationsPaths, {
            loaders: [new codeFileLoader.CodeFileLoader(), new graphqlFileLoader.GraphQLFileLoader()],
            skipGraphQLImport: true,
            cwd: process.cwd(),
        });
    }
    else {
        const rootTypeMap = {
            query: schema.getQueryType(),
            mutation: schema.getMutationType(),
            subscription: schema.getSubscriptionType(),
        };
        for (const operationType in rootTypeMap) {
            const rootType = rootTypeMap[operationType];
            if (rootType) {
                for (const fieldName in rootType.getFields()) {
                    const operation = utils.buildOperationNodeForField({
                        schema,
                        field: fieldName,
                        kind: operationType,
                        depthLimit,
                    });
                    const document = {
                        kind: graphql.Kind.DOCUMENT,
                        definitions: [operation],
                    };
                    sources.push({
                        document,
                        rawSDL: graphql.print(document),
                        location: `${fieldName}_${operationType}.graphql`,
                    });
                }
            }
        }
    }
    const output = await core.codegen({
        filename: 'types.ts',
        pluginMap: {
            typescript: tsBasePlugin,
            typescriptOperations: tsOperationsPlugin,
            typescriptGenericSdk: tsGenericSdkPlugin,
        },
        documents: sources,
        skipDocumentsValidation: true,
        schema: undefined,
        schemaAst: schema,
        plugins: [
            {
                typescript: {},
            },
            {
                typescriptOperations: {},
            },
            {
                typescriptGenericSdk: {},
            },
        ],
        config: {
            flattenGeneratedTypes: true,
            scalars: scalarsMap,
        },
    });
    return output;
}

function playground(exampleQuery, graphqlPath) {
    return async (req, res, next) => {
        if (req.query.query) {
            next();
            return;
        }
        res.setHeader('Content-Type', 'text/html');
        res.write(`
          <script>
              const localStorageMock = new Map();
              Object.defineProperty(window, 'localStorage', {
                get() {
                  return {
                    getItem(key) {
                      return localStorageMock.get(key);
                    },
                    setItem(key, val) {
                      return localStorageMock.set(key, val);
                    },
                    clear() {
                      return localStorageMock.clear();
                    },
                    key(i) {
                      return localStorageMock.keys()[i];
                    },
                    remove(key) {
                      return localStorageMock.delete(key);
                    },
                    get length() {
                      return localStorageMock.size;
                    }
                  }
                }
              });
            </script>
        `);
        const renderPageOptions = {
            title: 'GraphQL Mesh Playground',
        };
        if (exampleQuery) {
            const documents = await load.loadDocuments(exampleQuery, {
                loaders: [new codeFileLoader.CodeFileLoader(), new graphqlFileLoader.GraphQLFileLoader()],
                cwd: process.cwd(),
            });
            renderPageOptions.tabs = documents.map(doc => ({
                name: doc.location && path.basename(doc.location),
                query: doc.rawSDL,
            }));
        }
        res.write(await fsExtra.readFile(path.resolve(__dirname, './playground.html'), 'utf8'));
        res.write(`
            <script>
            window.addEventListener('load', function (event) {
                const renderPageOptions = ${JSON.stringify(renderPageOptions)};
                const endpoint = location.protocol + '//' + location.hostname + (location.port ? (':' + location.port) : '') + '${graphqlPath}';
                renderPageOptions.endpoint = endpoint;
                if (renderPageOptions.tabs) {
                    renderPageOptions.tabs.forEach(tab => {
                        tab.endpoint = endpoint;
                    });
                }
                GraphQLPlayground.init(document.getElementById('root'), renderPageOptions);
            });
            </script>
        `);
        res.end();
    };
}

async function serveMesh(logger, schema, contextBuilder, fork, port = 4000, exampleQuery) {
    var _a;
    const graphqlPath = '/graphql';
    if (cluster.isMaster && fork) {
        fork = fork > 1 ? fork : os.cpus().length;
        for (let i = 0; i < fork; i++) {
            cluster.fork();
        }
        logger.info(`🕸️ => Serving GraphQL Mesh GraphiQL: http://localhost:${port}${graphqlPath} in ${fork} forks`);
    }
    else {
        const app = express();
        app.set('trust proxy', 'loopback');
        const httpServer = http.createServer(app);
        if (((_a = process.env.NODE_ENV) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== 'production') {
            const playgroundMiddleware = playground(exampleQuery, graphqlPath);
            app.get('/', playgroundMiddleware);
            app.get(graphqlPath, playgroundMiddleware);
        }
        app.use(graphqlUpload.graphqlUploadExpress({ maxFileSize: 10000000, maxFiles: 10 }), graphqlHTTP(async (req) => ({
            schema,
            context: await contextBuilder(req),
            graphiql: false,
        })));
        subscriptionsTransportWs.SubscriptionServer.create({
            schema,
            execute: graphql.execute,
            subscribe: graphql.subscribe,
            onConnect: async function (_params, _webSocket, connectionContext) {
                const context = await contextBuilder(connectionContext.request);
                return context;
            },
        }, {
            server: httpServer,
            path: graphqlPath,
        });
        httpServer.listen(port.toString(), () => {
            if (!fork) {
                logger.info(`🕸️ => Serving GraphQL Mesh Playground: http://localhost:${port}${graphqlPath}`);
            }
        });
    }
}

const logger = winston.createLogger({
    level: 'info',
    format: winston.format.prettyPrint(),
    transports: [
        new winston.transports.Console({
            format: winston.format.simple(),
        }),
    ],
});
async function graphqlMesh() {
    return yargs.command('serve', 'Serves a GraphiQLApolloServer interface to test your Mesh API', builder => {
        builder.option('fork', {
            required: false,
            number: true,
            count: true,
        });
        builder.option('port', {
            required: false,
        });
        builder.option('example-query', {
            required: false,
            string: true,
        });
    }, async ({ fork, port, 'example-query': exampleQuery }) => {
        try {
            const meshConfig = await runtime.findAndParseConfig();
            const { schema, contextBuilder } = await runtime.getMesh(meshConfig);
            await serveMesh(logger, schema, contextBuilder, fork, port, exampleQuery);
        }
        catch (e) {
            logger.error('Unable to serve mesh: ', e);
        }
    })
        .command('generate-sdk', 'Generates fully type-safe SDK based on unifid GraphQL schema and GraphQL operations', builder => {
        builder
            .option('operations', {
            type: 'array',
        })
            .option('depth', {
            type: 'number',
        })
            .option('output', {
            required: true,
            type: 'string',
        });
    }, async (args) => {
        const meshConfig = await runtime.findAndParseConfig({
            ignoreAdditionalResolvers: true,
        });
        const { schema, destroy } = await runtime.getMesh(meshConfig);
        const result = await generateSdk(schema, args);
        const outFile = path.resolve(process.cwd(), args.output);
        await fsExtra.ensureFile(outFile);
        await fsExtra.writeFile(outFile, result);
        destroy();
    })
        .command('typescript', 'Generates TypeScript typings for the generated mesh', builder => {
        builder.option('output', {
            required: true,
            type: 'string',
        });
    }, async (args) => {
        const meshConfig = await runtime.findAndParseConfig({
            ignoreAdditionalResolvers: true,
        });
        const { schema, rawSources, destroy } = await runtime.getMesh(meshConfig);
        const result = await generateTsTypes(schema, rawSources, meshConfig.mergerType);
        const outFile = path.resolve(process.cwd(), args.output);
        await fsExtra.ensureFile(outFile);
        await fsExtra.writeFile(outFile, result);
        destroy();
    }).argv;
}
graphqlMesh()
    .then(() => { })
    .catch(e => {
    logger.error(e);
});

exports.graphqlMesh = graphqlMesh;
//# sourceMappingURL=index.cjs.js.map
