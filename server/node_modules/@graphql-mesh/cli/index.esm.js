import { findAndParseConfig, getMesh } from '@graphql-mesh/runtime';
import { command } from 'yargs';
import { createLogger, format, transports } from 'winston';
import * as tsBasePlugin from '@graphql-codegen/typescript';
import { TsVisitor } from '@graphql-codegen/typescript';
import * as tsResolversPlugin from '@graphql-codegen/typescript-resolvers';
import { Kind, print, execute, subscribe } from 'graphql';
import { codegen } from '@graphql-codegen/core';
import * as tsOperationsPlugin from '@graphql-codegen/typescript-operations';
import * as tsGenericSdkPlugin from '@graphql-codegen/typescript-generic-sdk';
import { loadDocuments } from '@graphql-tools/load';
import { CodeFileLoader } from '@graphql-tools/code-file-loader';
import { GraphQLFileLoader } from '@graphql-tools/graphql-file-loader';
import { buildOperationNodeForField } from '@graphql-tools/utils';
import express from 'express';
import { isMaster, fork } from 'cluster';
import { cpus } from 'os';
import 'json-bigint-patch';
import { createServer } from 'http';
import { basename, resolve } from 'path';
import { readFile, ensureFile, writeFile } from 'fs-extra';
import graphqlHTTP from 'express-graphql';
import { graphqlUploadExpress } from 'graphql-upload';
import { SubscriptionServer } from 'subscriptions-transport-ws';

const scalarsMap = {
    BigInt: 'BigInt',
    Byte: 'Buffer',
    Date: 'Date',
    DateTime: 'Date',
    GUID: 'String',
};

const unifiedContextIdentifier = 'MeshContext';
class CodegenHelpers extends TsVisitor {
    getTypeToUse(namedType) {
        if (this.scalars[namedType.name.value]) {
            return this._getScalar(namedType.name.value);
        }
        return this._getTypeForNode(namedType);
    }
}
function buildSignatureBasedOnRootFields(codegenHelpers, type) {
    if (!type) {
        return [];
    }
    const fields = type.getFields();
    return Object.keys(fields).map(fieldName => {
        const field = fields[fieldName];
        const argsExists = field.args && field.args.length > 0;
        const argsName = argsExists ? `${type.name}${codegenHelpers.convertName(field.name)}Args` : '{}';
        const parentTypeNode = {
            kind: Kind.NAMED_TYPE,
            name: {
                kind: Kind.NAME,
                value: type.name,
            },
        };
        return `  ${field.name}: (args${argsExists ? '' : '?'}: ${argsName}, projectionOptions?: ProjectionOptions) => Promise<${codegenHelpers.getTypeToUse(parentTypeNode)}['${fieldName}']>`;
    });
}
function generateTypesForApi(options) {
    const codegenHelpers = new CodegenHelpers(options.schema, {}, {});
    const sdkIdentifier = `${options.name}Sdk`;
    const contextIdentifier = `${options.name}Context`;
    const operations = [
        ...buildSignatureBasedOnRootFields(codegenHelpers, options.schema.getQueryType()),
        ...buildSignatureBasedOnRootFields(codegenHelpers, options.schema.getMutationType()),
        ...buildSignatureBasedOnRootFields(codegenHelpers, options.schema.getSubscriptionType()),
    ];
    const sdk = {
        identifier: sdkIdentifier,
        codeAst: `export type ${sdkIdentifier} = {
${operations.join(',\n')}
};`,
    };
    const context = {
        identifier: contextIdentifier,
        codeAst: `export type ${contextIdentifier} = { 
      ${options.name}: { api: ${sdkIdentifier} }, 
    };`,
    };
    return {
        sdk,
        context,
    };
}
function generateTsTypes(unifiedSchema, rawSources, mergerType = 'stitching') {
    return codegen({
        filename: 'types.ts',
        documents: [],
        config: {
            scalars: scalarsMap,
            skipTypename: true,
        },
        schemaAst: unifiedSchema,
        schema: undefined,
        pluginMap: {
            typescript: tsBasePlugin,
            resolvers: tsResolversPlugin,
            contextSdk: {
                plugin: async () => {
                    const commonTypes = [
                        `import { MeshContext as OriginalMeshContext, ProjectionOptions } from '@graphql-mesh/runtime';`,
                    ];
                    const sdkItems = [];
                    const contextItems = [];
                    const results = await Promise.all(rawSources.map(source => {
                        const item = generateTypesForApi({
                            schema: unifiedSchema.extensions.sourceMap.get(source),
                            name: source.name,
                        });
                        if (item) {
                            if (item.sdk) {
                                sdkItems.push(item.sdk.codeAst);
                            }
                            if (item.context) {
                                contextItems.push(item.context.codeAst);
                            }
                        }
                        return item;
                    }));
                    const contextType = `export type ${unifiedContextIdentifier} = ${results
                        .map(r => { var _a; return (_a = r === null || r === void 0 ? void 0 : r.context) === null || _a === void 0 ? void 0 : _a.identifier; })
                        .filter(Boolean)
                        .join(' & ')} & OriginalMeshContext;`;
                    return {
                        content: [...commonTypes, ...sdkItems, ...contextItems, contextType].join('\n\n'),
                    };
                },
            },
        },
        plugins: [
            {
                typescript: {
                    namingConvention: {
                        enumValues: 'keep',
                    },
                },
            },
            {
                resolvers: {
                    useIndexSignature: true,
                    noSchemaStitching: mergerType !== 'stitching',
                    contextType: unifiedContextIdentifier,
                    federation: mergerType === 'federation',
                },
            },
            {
                contextSdk: {},
            },
        ],
    });
}

async function generateSdk(schema, { operations: operationsPaths = [], depth: depthLimit = 1, }) {
    let sources = [];
    if (operationsPaths.length) {
        sources = await loadDocuments(operationsPaths, {
            loaders: [new CodeFileLoader(), new GraphQLFileLoader()],
            skipGraphQLImport: true,
            cwd: process.cwd(),
        });
    }
    else {
        const rootTypeMap = {
            query: schema.getQueryType(),
            mutation: schema.getMutationType(),
            subscription: schema.getSubscriptionType(),
        };
        for (const operationType in rootTypeMap) {
            const rootType = rootTypeMap[operationType];
            if (rootType) {
                for (const fieldName in rootType.getFields()) {
                    const operation = buildOperationNodeForField({
                        schema,
                        field: fieldName,
                        kind: operationType,
                        depthLimit,
                    });
                    const document = {
                        kind: Kind.DOCUMENT,
                        definitions: [operation],
                    };
                    sources.push({
                        document,
                        rawSDL: print(document),
                        location: `${fieldName}_${operationType}.graphql`,
                    });
                }
            }
        }
    }
    const output = await codegen({
        filename: 'types.ts',
        pluginMap: {
            typescript: tsBasePlugin,
            typescriptOperations: tsOperationsPlugin,
            typescriptGenericSdk: tsGenericSdkPlugin,
        },
        documents: sources,
        skipDocumentsValidation: true,
        schema: undefined,
        schemaAst: schema,
        plugins: [
            {
                typescript: {},
            },
            {
                typescriptOperations: {},
            },
            {
                typescriptGenericSdk: {},
            },
        ],
        config: {
            flattenGeneratedTypes: true,
            scalars: scalarsMap,
        },
    });
    return output;
}

function playground(exampleQuery, graphqlPath) {
    return async (req, res, next) => {
        if (req.query.query) {
            next();
            return;
        }
        res.setHeader('Content-Type', 'text/html');
        res.write(`
          <script>
              const localStorageMock = new Map();
              Object.defineProperty(window, 'localStorage', {
                get() {
                  return {
                    getItem(key) {
                      return localStorageMock.get(key);
                    },
                    setItem(key, val) {
                      return localStorageMock.set(key, val);
                    },
                    clear() {
                      return localStorageMock.clear();
                    },
                    key(i) {
                      return localStorageMock.keys()[i];
                    },
                    remove(key) {
                      return localStorageMock.delete(key);
                    },
                    get length() {
                      return localStorageMock.size;
                    }
                  }
                }
              });
            </script>
        `);
        const renderPageOptions = {
            title: 'GraphQL Mesh Playground',
        };
        if (exampleQuery) {
            const documents = await loadDocuments(exampleQuery, {
                loaders: [new CodeFileLoader(), new GraphQLFileLoader()],
                cwd: process.cwd(),
            });
            renderPageOptions.tabs = documents.map(doc => ({
                name: doc.location && basename(doc.location),
                query: doc.rawSDL,
            }));
        }
        res.write(await readFile(resolve(__dirname, './playground.html'), 'utf8'));
        res.write(`
            <script>
            window.addEventListener('load', function (event) {
                const renderPageOptions = ${JSON.stringify(renderPageOptions)};
                const endpoint = location.protocol + '//' + location.hostname + (location.port ? (':' + location.port) : '') + '${graphqlPath}';
                renderPageOptions.endpoint = endpoint;
                if (renderPageOptions.tabs) {
                    renderPageOptions.tabs.forEach(tab => {
                        tab.endpoint = endpoint;
                    });
                }
                GraphQLPlayground.init(document.getElementById('root'), renderPageOptions);
            });
            </script>
        `);
        res.end();
    };
}

async function serveMesh(logger, schema, contextBuilder, fork$1, port = 4000, exampleQuery) {
    var _a;
    const graphqlPath = '/graphql';
    if (isMaster && fork$1) {
        fork$1 = fork$1 > 1 ? fork$1 : cpus().length;
        for (let i = 0; i < fork$1; i++) {
            fork();
        }
        logger.info(`ðŸ•¸ï¸ => Serving GraphQL Mesh GraphiQL: http://localhost:${port}${graphqlPath} in ${fork$1} forks`);
    }
    else {
        const app = express();
        app.set('trust proxy', 'loopback');
        const httpServer = createServer(app);
        if (((_a = process.env.NODE_ENV) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== 'production') {
            const playgroundMiddleware = playground(exampleQuery, graphqlPath);
            app.get('/', playgroundMiddleware);
            app.get(graphqlPath, playgroundMiddleware);
        }
        app.use(graphqlUploadExpress({ maxFileSize: 10000000, maxFiles: 10 }), graphqlHTTP(async (req) => ({
            schema,
            context: await contextBuilder(req),
            graphiql: false,
        })));
        SubscriptionServer.create({
            schema,
            execute,
            subscribe,
            onConnect: async function (_params, _webSocket, connectionContext) {
                const context = await contextBuilder(connectionContext.request);
                return context;
            },
        }, {
            server: httpServer,
            path: graphqlPath,
        });
        httpServer.listen(port.toString(), () => {
            if (!fork$1) {
                logger.info(`ðŸ•¸ï¸ => Serving GraphQL Mesh Playground: http://localhost:${port}${graphqlPath}`);
            }
        });
    }
}

const logger = createLogger({
    level: 'info',
    format: format.prettyPrint(),
    transports: [
        new transports.Console({
            format: format.simple(),
        }),
    ],
});
async function graphqlMesh() {
    return command('serve', 'Serves a GraphiQLApolloServer interface to test your Mesh API', builder => {
        builder.option('fork', {
            required: false,
            number: true,
            count: true,
        });
        builder.option('port', {
            required: false,
        });
        builder.option('example-query', {
            required: false,
            string: true,
        });
    }, async ({ fork, port, 'example-query': exampleQuery }) => {
        try {
            const meshConfig = await findAndParseConfig();
            const { schema, contextBuilder } = await getMesh(meshConfig);
            await serveMesh(logger, schema, contextBuilder, fork, port, exampleQuery);
        }
        catch (e) {
            logger.error('Unable to serve mesh: ', e);
        }
    })
        .command('generate-sdk', 'Generates fully type-safe SDK based on unifid GraphQL schema and GraphQL operations', builder => {
        builder
            .option('operations', {
            type: 'array',
        })
            .option('depth', {
            type: 'number',
        })
            .option('output', {
            required: true,
            type: 'string',
        });
    }, async (args) => {
        const meshConfig = await findAndParseConfig({
            ignoreAdditionalResolvers: true,
        });
        const { schema, destroy } = await getMesh(meshConfig);
        const result = await generateSdk(schema, args);
        const outFile = resolve(process.cwd(), args.output);
        await ensureFile(outFile);
        await writeFile(outFile, result);
        destroy();
    })
        .command('typescript', 'Generates TypeScript typings for the generated mesh', builder => {
        builder.option('output', {
            required: true,
            type: 'string',
        });
    }, async (args) => {
        const meshConfig = await findAndParseConfig({
            ignoreAdditionalResolvers: true,
        });
        const { schema, rawSources, destroy } = await getMesh(meshConfig);
        const result = await generateTsTypes(schema, rawSources, meshConfig.mergerType);
        const outFile = resolve(process.cwd(), args.output);
        await ensureFile(outFile);
        await writeFile(outFile, result);
        destroy();
    }).argv;
}
graphqlMesh()
    .then(() => { })
    .catch(e => {
    logger.error(e);
});

export { graphqlMesh };
//# sourceMappingURL=index.esm.js.map
