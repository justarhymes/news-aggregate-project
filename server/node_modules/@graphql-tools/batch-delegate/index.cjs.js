'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

const graphql = require('graphql');
const DataLoader = _interopDefault(require('dataloader'));
const delegate = require('@graphql-tools/delegate');

function createBatchDelegateFn(argFn, batchDelegateOptionsFn, dataLoaderOptions) {
    let cache;
    function createBatchFn(options) {
        return async (keys) => {
            const results = await delegate.delegateToSchema({
                returnType: new graphql.GraphQLList(graphql.getNamedType(options.info.returnType)),
                args: argFn(keys),
                ...batchDelegateOptionsFn(options),
            });
            return Array.isArray(results) ? results : keys.map(() => results);
        };
    }
    function getLoader(options) {
        if (!cache) {
            cache = new WeakMap();
            const batchFn = createBatchFn(options);
            const newValue = new DataLoader(keys => batchFn(keys), dataLoaderOptions);
            cache.set(options.info.fieldNodes, newValue);
            return newValue;
        }
        const cachedValue = cache.get(options.info.fieldNodes);
        if (cachedValue === undefined) {
            const batchFn = createBatchFn(options);
            const newValue = new DataLoader(keys => batchFn(keys), dataLoaderOptions);
            cache.set(options.info.fieldNodes, newValue);
            return newValue;
        }
        return cachedValue;
    }
    return options => {
        const loader = getLoader(options);
        return loader.load(options.key);
    };
}

exports.createBatchDelegateFn = createBatchDelegateFn;
//# sourceMappingURL=index.cjs.js.map
