"use strict";

var _graphqlCompose = require("graphql-compose");

var _graphql = require("graphql-compose/lib/graphql");

var _composeWithPagination = require("../composeWithPagination");

var _User = require("../__mocks__/User");

/* eslint-disable no-param-reassign */
describe('composeWithRelay', () => {
  const userComposer = (0, _composeWithPagination.composeWithPagination)(_User.UserTC, {
    countResolverName: 'count',
    findResolverName: 'findMany',
    perPage: 5
  });
  describe('basic checks', () => {
    it('should return ObjectTypeComposer', () => {
      expect(userComposer).toBeInstanceOf(_graphqlCompose.ObjectTypeComposer);
      expect(userComposer).toBe(_User.UserTC);
    });
    it('should throw error if first arg is not ObjectTypeComposer', () => {
      expect(() => {
        const args = [123];
        (0, _composeWithPagination.composeWithPagination)(...args);
      }).toThrowError('should provide ObjectTypeComposer instance');
    });
    it('should throw error if options are empty', () => {
      expect(() => {
        const args = [_User.UserTC];
        (0, _composeWithPagination.composeWithPagination)(...args);
      }).toThrowError('should provide non-empty options');
    });
    it('should not change `pagination` resolver if exists', () => {
      let myTC = _graphqlCompose.schemaComposer.createObjectTC('type Complex { a: String, b: Int }');

      myTC.addResolver({
        name: 'pagination',
        resolve: () => 'mockData'
      }); // try ovewrite `pagination` resolver

      myTC = (0, _composeWithPagination.composeWithPagination)(myTC, {
        countResolverName: 'count',
        findResolverName: 'findMany'
      });
      expect(myTC.getResolver('pagination')).toBeTruthy();
      expect(myTC.getResolver('pagination').resolve({})).toBe('mockData');
    });
    it('should add resolver with user-specified name', () => {
      let myTC = _graphqlCompose.schemaComposer.createObjectTC('type CustomComplex { a: String, b: Int }');

      myTC.addResolver({
        name: 'count',
        resolve: () => 1
      });
      myTC.addResolver({
        name: 'findMany',
        resolve: () => ['mockData']
      });
      myTC = (0, _composeWithPagination.composeWithPagination)(myTC, {
        paginationResolverName: 'customPagination',
        countResolverName: 'count',
        findResolverName: 'findMany'
      });
      expect(myTC.getResolver('customPagination')).toBeTruthy();
      expect(myTC.hasResolver('pagination')).toBeFalsy();
    });
    it('should add two connection resolvers', () => {
      let myTC = _graphqlCompose.schemaComposer.createObjectTC('type CustomComplex { a: String, b: Int }');

      myTC.addResolver({
        name: 'count',
        resolve: () => 1
      });
      myTC.addResolver({
        name: 'findMany',
        resolve: () => ['mockData']
      });
      myTC = (0, _composeWithPagination.composeWithPagination)(myTC, {
        countResolverName: 'count',
        findResolverName: 'findMany'
      });
      myTC = (0, _composeWithPagination.composeWithPagination)(myTC, {
        paginationResolverName: 'customPagination',
        countResolverName: 'count',
        findResolverName: 'findMany'
      });
      expect(myTC.hasResolver('pagination')).toBeTruthy();
      expect(myTC.getResolver('customPagination')).toBeTruthy();
    });
  });
  describe('check `pagination` resolver props', () => {
    const rsv = userComposer.getResolver('pagination');
    const type = rsv.getType();

    const tc = _graphqlCompose.schemaComposer.createObjectTC(type);

    it('should exists', () => {
      expect(rsv).toBeTruthy();
    });
    it('should has PaginationType as type', () => {
      expect(type).toBeTruthy();
      expect(tc.getFieldNames()).toEqual(expect.arrayContaining(['count', 'pageInfo', 'items']));
      expect(tc.getFieldType('items')).toBeInstanceOf(_graphql.GraphQLList);
    });
  });
  describe('fragments fields projection of graphql-compose', () => {
    it('should return object', async () => {
      _graphqlCompose.schemaComposer.Query.setField('userPagination', _User.UserTC.getResolver('pagination'));

      const schema = _graphqlCompose.schemaComposer.buildSchema();

      const query = `{
        userPagination(page: 1, perPage: 2, sort: ID_ASC) {
          count,
          pageInfo {
            currentPage
            perPage
            itemCount
            pageCount
            ...on PaginationInfo {
              hasPreviousPage
              hasNextPage
            }
          }
          items {
            id
            name
            ...idNameAge
            ...on User {
              age
            }
          }
        }
      }
      fragment idNameAge on User {
        gender
      }
      `;
      const result = await (0, _graphql.graphql)(schema, query);
      expect(result).toEqual({
        data: {
          userPagination: {
            count: 15,
            items: [{
              age: 11,
              gender: 'm',
              id: 1,
              name: 'user01'
            }, {
              age: 12,
              gender: 'm',
              id: 2,
              name: 'user02'
            }],
            pageInfo: {
              currentPage: 1,
              hasNextPage: true,
              hasPreviousPage: false,
              itemCount: 15,
              pageCount: 8,
              perPage: 2
            }
          }
        }
      });
    });
  });
  it('should pass `countResolveParams` to top resolverParams', async () => {
    // first build
    let topResolveParams = {};

    _graphqlCompose.schemaComposer.Query.setField('userPagination', _User.UserTC.getResolver('pagination').wrapResolve(next => rp => {
      const result = next(rp);
      topResolveParams = rp;
      return result;
    }));

    const schema = _graphqlCompose.schemaComposer.buildSchema();

    const query = `{
      userPagination(filter: { age: 45 }) {
        count
      }
    }`;
    const res = await (0, _graphql.graphql)(schema, query);
    expect(res).toEqual({
      data: {
        userPagination: {
          count: 15
        }
      }
    });
    expect(Object.keys(topResolveParams.countResolveParams)).toEqual(expect.arrayContaining(['source', 'args', 'context', 'info', 'projection']));
    expect(topResolveParams.countResolveParams.args).toEqual({
      filter: {
        age: 45
      },
      perPage: 5
    }); // second build

    let topResolveParams2 = {};

    _graphqlCompose.schemaComposer.Query.setField('userPagination', _User.UserTC.getResolver('pagination').wrapResolve(next => rp => {
      const result = next(rp);
      topResolveParams2 = rp;
      return result;
    }));

    const schema2 = _graphqlCompose.schemaComposer.buildSchema();

    const query2 = `{
      userPagination(filter: { age: 333 }) {
        count
      }
    }`;
    const res2 = await (0, _graphql.graphql)(schema2, query2);
    expect(res2).toEqual({
      data: {
        userPagination: {
          count: 15
        }
      }
    });
    expect(Object.keys(topResolveParams2.countResolveParams)).toEqual(expect.arrayContaining(['source', 'args', 'context', 'info', 'projection']));
    expect(topResolveParams2.countResolveParams.args).toEqual({
      filter: {
        age: 333
      },
      perPage: 5
    });
  });
  it('should pass `findManyResolveParams` to top resolverParams', async () => {
    let topResolveParams = {};

    _graphqlCompose.schemaComposer.Query.setField('userPagination', _User.UserTC.getResolver('pagination').wrapResolve(next => rp => {
      const result = next(rp);
      topResolveParams = rp;
      return result;
    }));

    const schema = _graphqlCompose.schemaComposer.buildSchema();

    const query = `{
      userPagination(filter: { age: 55 }) {
        count
      }
    }`;
    const res = await (0, _graphql.graphql)(schema, query);
    expect(res).toEqual({
      data: {
        userPagination: {
          count: 15
        }
      }
    });
    expect(Object.keys(topResolveParams.findManyResolveParams)).toEqual(expect.arrayContaining(['source', 'args', 'context', 'info', 'projection']));
    expect(topResolveParams.findManyResolveParams.args).toEqual({
      filter: {
        age: 55
      },
      limit: 6,
      perPage: 5
    });
  });
});